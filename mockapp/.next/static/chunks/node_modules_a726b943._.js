(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push([typeof document === "object" ? document.currentScript : undefined, {

"[project]/node_modules/next/dist/compiled/buffer/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
(function() {
    var e = {
        675: function(e, r) {
            "use strict";
            r.byteLength = byteLength;
            r.toByteArray = toByteArray;
            r.fromByteArray = fromByteArray;
            var t = [];
            var f = [];
            var n = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
            var i = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
            for(var o = 0, u = i.length; o < u; ++o){
                t[o] = i[o];
                f[i.charCodeAt(o)] = o;
            }
            f["-".charCodeAt(0)] = 62;
            f["_".charCodeAt(0)] = 63;
            function getLens(e) {
                var r = e.length;
                if (r % 4 > 0) {
                    throw new Error("Invalid string. Length must be a multiple of 4");
                }
                var t = e.indexOf("=");
                if (t === -1) t = r;
                var f = t === r ? 0 : 4 - t % 4;
                return [
                    t,
                    f
                ];
            }
            function byteLength(e) {
                var r = getLens(e);
                var t = r[0];
                var f = r[1];
                return (t + f) * 3 / 4 - f;
            }
            function _byteLength(e, r, t) {
                return (r + t) * 3 / 4 - t;
            }
            function toByteArray(e) {
                var r;
                var t = getLens(e);
                var i = t[0];
                var o = t[1];
                var u = new n(_byteLength(e, i, o));
                var a = 0;
                var s = o > 0 ? i - 4 : i;
                var h;
                for(h = 0; h < s; h += 4){
                    r = f[e.charCodeAt(h)] << 18 | f[e.charCodeAt(h + 1)] << 12 | f[e.charCodeAt(h + 2)] << 6 | f[e.charCodeAt(h + 3)];
                    u[a++] = r >> 16 & 255;
                    u[a++] = r >> 8 & 255;
                    u[a++] = r & 255;
                }
                if (o === 2) {
                    r = f[e.charCodeAt(h)] << 2 | f[e.charCodeAt(h + 1)] >> 4;
                    u[a++] = r & 255;
                }
                if (o === 1) {
                    r = f[e.charCodeAt(h)] << 10 | f[e.charCodeAt(h + 1)] << 4 | f[e.charCodeAt(h + 2)] >> 2;
                    u[a++] = r >> 8 & 255;
                    u[a++] = r & 255;
                }
                return u;
            }
            function tripletToBase64(e) {
                return t[e >> 18 & 63] + t[e >> 12 & 63] + t[e >> 6 & 63] + t[e & 63];
            }
            function encodeChunk(e, r, t) {
                var f;
                var n = [];
                for(var i = r; i < t; i += 3){
                    f = (e[i] << 16 & 16711680) + (e[i + 1] << 8 & 65280) + (e[i + 2] & 255);
                    n.push(tripletToBase64(f));
                }
                return n.join("");
            }
            function fromByteArray(e) {
                var r;
                var f = e.length;
                var n = f % 3;
                var i = [];
                var o = 16383;
                for(var u = 0, a = f - n; u < a; u += o){
                    i.push(encodeChunk(e, u, u + o > a ? a : u + o));
                }
                if (n === 1) {
                    r = e[f - 1];
                    i.push(t[r >> 2] + t[r << 4 & 63] + "==");
                } else if (n === 2) {
                    r = (e[f - 2] << 8) + e[f - 1];
                    i.push(t[r >> 10] + t[r >> 4 & 63] + t[r << 2 & 63] + "=");
                }
                return i.join("");
            }
        },
        72: function(e, r, t) {
            "use strict";
            /*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */ var f = t(675);
            var n = t(783);
            var i = typeof Symbol === "function" && typeof Symbol.for === "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
            r.Buffer = Buffer;
            r.SlowBuffer = SlowBuffer;
            r.INSPECT_MAX_BYTES = 50;
            var o = 2147483647;
            r.kMaxLength = o;
            Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();
            if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
                console.error("This browser lacks typed array (Uint8Array) support which is required by " + "`buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
            }
            function typedArraySupport() {
                try {
                    var e = new Uint8Array(1);
                    var r = {
                        foo: function() {
                            return 42;
                        }
                    };
                    Object.setPrototypeOf(r, Uint8Array.prototype);
                    Object.setPrototypeOf(e, r);
                    return e.foo() === 42;
                } catch (e) {
                    return false;
                }
            }
            Object.defineProperty(Buffer.prototype, "parent", {
                enumerable: true,
                get: function() {
                    if (!Buffer.isBuffer(this)) return undefined;
                    return this.buffer;
                }
            });
            Object.defineProperty(Buffer.prototype, "offset", {
                enumerable: true,
                get: function() {
                    if (!Buffer.isBuffer(this)) return undefined;
                    return this.byteOffset;
                }
            });
            function createBuffer(e) {
                if (e > o) {
                    throw new RangeError('The value "' + e + '" is invalid for option "size"');
                }
                var r = new Uint8Array(e);
                Object.setPrototypeOf(r, Buffer.prototype);
                return r;
            }
            function Buffer(e, r, t) {
                if (typeof e === "number") {
                    if (typeof r === "string") {
                        throw new TypeError('The "string" argument must be of type string. Received type number');
                    }
                    return allocUnsafe(e);
                }
                return from(e, r, t);
            }
            Buffer.poolSize = 8192;
            function from(e, r, t) {
                if (typeof e === "string") {
                    return fromString(e, r);
                }
                if (ArrayBuffer.isView(e)) {
                    return fromArrayLike(e);
                }
                if (e == null) {
                    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, " + "or Array-like Object. Received type " + typeof e);
                }
                if (isInstance(e, ArrayBuffer) || e && isInstance(e.buffer, ArrayBuffer)) {
                    return fromArrayBuffer(e, r, t);
                }
                if (typeof SharedArrayBuffer !== "undefined" && (isInstance(e, SharedArrayBuffer) || e && isInstance(e.buffer, SharedArrayBuffer))) {
                    return fromArrayBuffer(e, r, t);
                }
                if (typeof e === "number") {
                    throw new TypeError('The "value" argument must not be of type number. Received type number');
                }
                var f = e.valueOf && e.valueOf();
                if (f != null && f !== e) {
                    return Buffer.from(f, r, t);
                }
                var n = fromObject(e);
                if (n) return n;
                if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof e[Symbol.toPrimitive] === "function") {
                    return Buffer.from(e[Symbol.toPrimitive]("string"), r, t);
                }
                throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, " + "or Array-like Object. Received type " + typeof e);
            }
            Buffer.from = function(e, r, t) {
                return from(e, r, t);
            };
            Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
            Object.setPrototypeOf(Buffer, Uint8Array);
            function assertSize(e) {
                if (typeof e !== "number") {
                    throw new TypeError('"size" argument must be of type number');
                } else if (e < 0) {
                    throw new RangeError('The value "' + e + '" is invalid for option "size"');
                }
            }
            function alloc(e, r, t) {
                assertSize(e);
                if (e <= 0) {
                    return createBuffer(e);
                }
                if (r !== undefined) {
                    return typeof t === "string" ? createBuffer(e).fill(r, t) : createBuffer(e).fill(r);
                }
                return createBuffer(e);
            }
            Buffer.alloc = function(e, r, t) {
                return alloc(e, r, t);
            };
            function allocUnsafe(e) {
                assertSize(e);
                return createBuffer(e < 0 ? 0 : checked(e) | 0);
            }
            Buffer.allocUnsafe = function(e) {
                return allocUnsafe(e);
            };
            Buffer.allocUnsafeSlow = function(e) {
                return allocUnsafe(e);
            };
            function fromString(e, r) {
                if (typeof r !== "string" || r === "") {
                    r = "utf8";
                }
                if (!Buffer.isEncoding(r)) {
                    throw new TypeError("Unknown encoding: " + r);
                }
                var t = byteLength(e, r) | 0;
                var f = createBuffer(t);
                var n = f.write(e, r);
                if (n !== t) {
                    f = f.slice(0, n);
                }
                return f;
            }
            function fromArrayLike(e) {
                var r = e.length < 0 ? 0 : checked(e.length) | 0;
                var t = createBuffer(r);
                for(var f = 0; f < r; f += 1){
                    t[f] = e[f] & 255;
                }
                return t;
            }
            function fromArrayBuffer(e, r, t) {
                if (r < 0 || e.byteLength < r) {
                    throw new RangeError('"offset" is outside of buffer bounds');
                }
                if (e.byteLength < r + (t || 0)) {
                    throw new RangeError('"length" is outside of buffer bounds');
                }
                var f;
                if (r === undefined && t === undefined) {
                    f = new Uint8Array(e);
                } else if (t === undefined) {
                    f = new Uint8Array(e, r);
                } else {
                    f = new Uint8Array(e, r, t);
                }
                Object.setPrototypeOf(f, Buffer.prototype);
                return f;
            }
            function fromObject(e) {
                if (Buffer.isBuffer(e)) {
                    var r = checked(e.length) | 0;
                    var t = createBuffer(r);
                    if (t.length === 0) {
                        return t;
                    }
                    e.copy(t, 0, 0, r);
                    return t;
                }
                if (e.length !== undefined) {
                    if (typeof e.length !== "number" || numberIsNaN(e.length)) {
                        return createBuffer(0);
                    }
                    return fromArrayLike(e);
                }
                if (e.type === "Buffer" && Array.isArray(e.data)) {
                    return fromArrayLike(e.data);
                }
            }
            function checked(e) {
                if (e >= o) {
                    throw new RangeError("Attempt to allocate Buffer larger than maximum " + "size: 0x" + o.toString(16) + " bytes");
                }
                return e | 0;
            }
            function SlowBuffer(e) {
                if (+e != e) {
                    e = 0;
                }
                return Buffer.alloc(+e);
            }
            Buffer.isBuffer = function isBuffer(e) {
                return e != null && e._isBuffer === true && e !== Buffer.prototype;
            };
            Buffer.compare = function compare(e, r) {
                if (isInstance(e, Uint8Array)) e = Buffer.from(e, e.offset, e.byteLength);
                if (isInstance(r, Uint8Array)) r = Buffer.from(r, r.offset, r.byteLength);
                if (!Buffer.isBuffer(e) || !Buffer.isBuffer(r)) {
                    throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
                }
                if (e === r) return 0;
                var t = e.length;
                var f = r.length;
                for(var n = 0, i = Math.min(t, f); n < i; ++n){
                    if (e[n] !== r[n]) {
                        t = e[n];
                        f = r[n];
                        break;
                    }
                }
                if (t < f) return -1;
                if (f < t) return 1;
                return 0;
            };
            Buffer.isEncoding = function isEncoding(e) {
                switch(String(e).toLowerCase()){
                    case "hex":
                    case "utf8":
                    case "utf-8":
                    case "ascii":
                    case "latin1":
                    case "binary":
                    case "base64":
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                        return true;
                    default:
                        return false;
                }
            };
            Buffer.concat = function concat(e, r) {
                if (!Array.isArray(e)) {
                    throw new TypeError('"list" argument must be an Array of Buffers');
                }
                if (e.length === 0) {
                    return Buffer.alloc(0);
                }
                var t;
                if (r === undefined) {
                    r = 0;
                    for(t = 0; t < e.length; ++t){
                        r += e[t].length;
                    }
                }
                var f = Buffer.allocUnsafe(r);
                var n = 0;
                for(t = 0; t < e.length; ++t){
                    var i = e[t];
                    if (isInstance(i, Uint8Array)) {
                        i = Buffer.from(i);
                    }
                    if (!Buffer.isBuffer(i)) {
                        throw new TypeError('"list" argument must be an Array of Buffers');
                    }
                    i.copy(f, n);
                    n += i.length;
                }
                return f;
            };
            function byteLength(e, r) {
                if (Buffer.isBuffer(e)) {
                    return e.length;
                }
                if (ArrayBuffer.isView(e) || isInstance(e, ArrayBuffer)) {
                    return e.byteLength;
                }
                if (typeof e !== "string") {
                    throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' + "Received type " + typeof e);
                }
                var t = e.length;
                var f = arguments.length > 2 && arguments[2] === true;
                if (!f && t === 0) return 0;
                var n = false;
                for(;;){
                    switch(r){
                        case "ascii":
                        case "latin1":
                        case "binary":
                            return t;
                        case "utf8":
                        case "utf-8":
                            return utf8ToBytes(e).length;
                        case "ucs2":
                        case "ucs-2":
                        case "utf16le":
                        case "utf-16le":
                            return t * 2;
                        case "hex":
                            return t >>> 1;
                        case "base64":
                            return base64ToBytes(e).length;
                        default:
                            if (n) {
                                return f ? -1 : utf8ToBytes(e).length;
                            }
                            r = ("" + r).toLowerCase();
                            n = true;
                    }
                }
            }
            Buffer.byteLength = byteLength;
            function slowToString(e, r, t) {
                var f = false;
                if (r === undefined || r < 0) {
                    r = 0;
                }
                if (r > this.length) {
                    return "";
                }
                if (t === undefined || t > this.length) {
                    t = this.length;
                }
                if (t <= 0) {
                    return "";
                }
                t >>>= 0;
                r >>>= 0;
                if (t <= r) {
                    return "";
                }
                if (!e) e = "utf8";
                while(true){
                    switch(e){
                        case "hex":
                            return hexSlice(this, r, t);
                        case "utf8":
                        case "utf-8":
                            return utf8Slice(this, r, t);
                        case "ascii":
                            return asciiSlice(this, r, t);
                        case "latin1":
                        case "binary":
                            return latin1Slice(this, r, t);
                        case "base64":
                            return base64Slice(this, r, t);
                        case "ucs2":
                        case "ucs-2":
                        case "utf16le":
                        case "utf-16le":
                            return utf16leSlice(this, r, t);
                        default:
                            if (f) throw new TypeError("Unknown encoding: " + e);
                            e = (e + "").toLowerCase();
                            f = true;
                    }
                }
            }
            Buffer.prototype._isBuffer = true;
            function swap(e, r, t) {
                var f = e[r];
                e[r] = e[t];
                e[t] = f;
            }
            Buffer.prototype.swap16 = function swap16() {
                var e = this.length;
                if (e % 2 !== 0) {
                    throw new RangeError("Buffer size must be a multiple of 16-bits");
                }
                for(var r = 0; r < e; r += 2){
                    swap(this, r, r + 1);
                }
                return this;
            };
            Buffer.prototype.swap32 = function swap32() {
                var e = this.length;
                if (e % 4 !== 0) {
                    throw new RangeError("Buffer size must be a multiple of 32-bits");
                }
                for(var r = 0; r < e; r += 4){
                    swap(this, r, r + 3);
                    swap(this, r + 1, r + 2);
                }
                return this;
            };
            Buffer.prototype.swap64 = function swap64() {
                var e = this.length;
                if (e % 8 !== 0) {
                    throw new RangeError("Buffer size must be a multiple of 64-bits");
                }
                for(var r = 0; r < e; r += 8){
                    swap(this, r, r + 7);
                    swap(this, r + 1, r + 6);
                    swap(this, r + 2, r + 5);
                    swap(this, r + 3, r + 4);
                }
                return this;
            };
            Buffer.prototype.toString = function toString() {
                var e = this.length;
                if (e === 0) return "";
                if (arguments.length === 0) return utf8Slice(this, 0, e);
                return slowToString.apply(this, arguments);
            };
            Buffer.prototype.toLocaleString = Buffer.prototype.toString;
            Buffer.prototype.equals = function equals(e) {
                if (!Buffer.isBuffer(e)) throw new TypeError("Argument must be a Buffer");
                if (this === e) return true;
                return Buffer.compare(this, e) === 0;
            };
            Buffer.prototype.inspect = function inspect() {
                var e = "";
                var t = r.INSPECT_MAX_BYTES;
                e = this.toString("hex", 0, t).replace(/(.{2})/g, "$1 ").trim();
                if (this.length > t) e += " ... ";
                return "<Buffer " + e + ">";
            };
            if (i) {
                Buffer.prototype[i] = Buffer.prototype.inspect;
            }
            Buffer.prototype.compare = function compare(e, r, t, f, n) {
                if (isInstance(e, Uint8Array)) {
                    e = Buffer.from(e, e.offset, e.byteLength);
                }
                if (!Buffer.isBuffer(e)) {
                    throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. ' + "Received type " + typeof e);
                }
                if (r === undefined) {
                    r = 0;
                }
                if (t === undefined) {
                    t = e ? e.length : 0;
                }
                if (f === undefined) {
                    f = 0;
                }
                if (n === undefined) {
                    n = this.length;
                }
                if (r < 0 || t > e.length || f < 0 || n > this.length) {
                    throw new RangeError("out of range index");
                }
                if (f >= n && r >= t) {
                    return 0;
                }
                if (f >= n) {
                    return -1;
                }
                if (r >= t) {
                    return 1;
                }
                r >>>= 0;
                t >>>= 0;
                f >>>= 0;
                n >>>= 0;
                if (this === e) return 0;
                var i = n - f;
                var o = t - r;
                var u = Math.min(i, o);
                var a = this.slice(f, n);
                var s = e.slice(r, t);
                for(var h = 0; h < u; ++h){
                    if (a[h] !== s[h]) {
                        i = a[h];
                        o = s[h];
                        break;
                    }
                }
                if (i < o) return -1;
                if (o < i) return 1;
                return 0;
            };
            function bidirectionalIndexOf(e, r, t, f, n) {
                if (e.length === 0) return -1;
                if (typeof t === "string") {
                    f = t;
                    t = 0;
                } else if (t > 2147483647) {
                    t = 2147483647;
                } else if (t < -2147483648) {
                    t = -2147483648;
                }
                t = +t;
                if (numberIsNaN(t)) {
                    t = n ? 0 : e.length - 1;
                }
                if (t < 0) t = e.length + t;
                if (t >= e.length) {
                    if (n) return -1;
                    else t = e.length - 1;
                } else if (t < 0) {
                    if (n) t = 0;
                    else return -1;
                }
                if (typeof r === "string") {
                    r = Buffer.from(r, f);
                }
                if (Buffer.isBuffer(r)) {
                    if (r.length === 0) {
                        return -1;
                    }
                    return arrayIndexOf(e, r, t, f, n);
                } else if (typeof r === "number") {
                    r = r & 255;
                    if (typeof Uint8Array.prototype.indexOf === "function") {
                        if (n) {
                            return Uint8Array.prototype.indexOf.call(e, r, t);
                        } else {
                            return Uint8Array.prototype.lastIndexOf.call(e, r, t);
                        }
                    }
                    return arrayIndexOf(e, [
                        r
                    ], t, f, n);
                }
                throw new TypeError("val must be string, number or Buffer");
            }
            function arrayIndexOf(e, r, t, f, n) {
                var i = 1;
                var o = e.length;
                var u = r.length;
                if (f !== undefined) {
                    f = String(f).toLowerCase();
                    if (f === "ucs2" || f === "ucs-2" || f === "utf16le" || f === "utf-16le") {
                        if (e.length < 2 || r.length < 2) {
                            return -1;
                        }
                        i = 2;
                        o /= 2;
                        u /= 2;
                        t /= 2;
                    }
                }
                function read(e, r) {
                    if (i === 1) {
                        return e[r];
                    } else {
                        return e.readUInt16BE(r * i);
                    }
                }
                var a;
                if (n) {
                    var s = -1;
                    for(a = t; a < o; a++){
                        if (read(e, a) === read(r, s === -1 ? 0 : a - s)) {
                            if (s === -1) s = a;
                            if (a - s + 1 === u) return s * i;
                        } else {
                            if (s !== -1) a -= a - s;
                            s = -1;
                        }
                    }
                } else {
                    if (t + u > o) t = o - u;
                    for(a = t; a >= 0; a--){
                        var h = true;
                        for(var c = 0; c < u; c++){
                            if (read(e, a + c) !== read(r, c)) {
                                h = false;
                                break;
                            }
                        }
                        if (h) return a;
                    }
                }
                return -1;
            }
            Buffer.prototype.includes = function includes(e, r, t) {
                return this.indexOf(e, r, t) !== -1;
            };
            Buffer.prototype.indexOf = function indexOf(e, r, t) {
                return bidirectionalIndexOf(this, e, r, t, true);
            };
            Buffer.prototype.lastIndexOf = function lastIndexOf(e, r, t) {
                return bidirectionalIndexOf(this, e, r, t, false);
            };
            function hexWrite(e, r, t, f) {
                t = Number(t) || 0;
                var n = e.length - t;
                if (!f) {
                    f = n;
                } else {
                    f = Number(f);
                    if (f > n) {
                        f = n;
                    }
                }
                var i = r.length;
                if (f > i / 2) {
                    f = i / 2;
                }
                for(var o = 0; o < f; ++o){
                    var u = parseInt(r.substr(o * 2, 2), 16);
                    if (numberIsNaN(u)) return o;
                    e[t + o] = u;
                }
                return o;
            }
            function utf8Write(e, r, t, f) {
                return blitBuffer(utf8ToBytes(r, e.length - t), e, t, f);
            }
            function asciiWrite(e, r, t, f) {
                return blitBuffer(asciiToBytes(r), e, t, f);
            }
            function latin1Write(e, r, t, f) {
                return asciiWrite(e, r, t, f);
            }
            function base64Write(e, r, t, f) {
                return blitBuffer(base64ToBytes(r), e, t, f);
            }
            function ucs2Write(e, r, t, f) {
                return blitBuffer(utf16leToBytes(r, e.length - t), e, t, f);
            }
            Buffer.prototype.write = function write(e, r, t, f) {
                if (r === undefined) {
                    f = "utf8";
                    t = this.length;
                    r = 0;
                } else if (t === undefined && typeof r === "string") {
                    f = r;
                    t = this.length;
                    r = 0;
                } else if (isFinite(r)) {
                    r = r >>> 0;
                    if (isFinite(t)) {
                        t = t >>> 0;
                        if (f === undefined) f = "utf8";
                    } else {
                        f = t;
                        t = undefined;
                    }
                } else {
                    throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
                }
                var n = this.length - r;
                if (t === undefined || t > n) t = n;
                if (e.length > 0 && (t < 0 || r < 0) || r > this.length) {
                    throw new RangeError("Attempt to write outside buffer bounds");
                }
                if (!f) f = "utf8";
                var i = false;
                for(;;){
                    switch(f){
                        case "hex":
                            return hexWrite(this, e, r, t);
                        case "utf8":
                        case "utf-8":
                            return utf8Write(this, e, r, t);
                        case "ascii":
                            return asciiWrite(this, e, r, t);
                        case "latin1":
                        case "binary":
                            return latin1Write(this, e, r, t);
                        case "base64":
                            return base64Write(this, e, r, t);
                        case "ucs2":
                        case "ucs-2":
                        case "utf16le":
                        case "utf-16le":
                            return ucs2Write(this, e, r, t);
                        default:
                            if (i) throw new TypeError("Unknown encoding: " + f);
                            f = ("" + f).toLowerCase();
                            i = true;
                    }
                }
            };
            Buffer.prototype.toJSON = function toJSON() {
                return {
                    type: "Buffer",
                    data: Array.prototype.slice.call(this._arr || this, 0)
                };
            };
            function base64Slice(e, r, t) {
                if (r === 0 && t === e.length) {
                    return f.fromByteArray(e);
                } else {
                    return f.fromByteArray(e.slice(r, t));
                }
            }
            function utf8Slice(e, r, t) {
                t = Math.min(e.length, t);
                var f = [];
                var n = r;
                while(n < t){
                    var i = e[n];
                    var o = null;
                    var u = i > 239 ? 4 : i > 223 ? 3 : i > 191 ? 2 : 1;
                    if (n + u <= t) {
                        var a, s, h, c;
                        switch(u){
                            case 1:
                                if (i < 128) {
                                    o = i;
                                }
                                break;
                            case 2:
                                a = e[n + 1];
                                if ((a & 192) === 128) {
                                    c = (i & 31) << 6 | a & 63;
                                    if (c > 127) {
                                        o = c;
                                    }
                                }
                                break;
                            case 3:
                                a = e[n + 1];
                                s = e[n + 2];
                                if ((a & 192) === 128 && (s & 192) === 128) {
                                    c = (i & 15) << 12 | (a & 63) << 6 | s & 63;
                                    if (c > 2047 && (c < 55296 || c > 57343)) {
                                        o = c;
                                    }
                                }
                                break;
                            case 4:
                                a = e[n + 1];
                                s = e[n + 2];
                                h = e[n + 3];
                                if ((a & 192) === 128 && (s & 192) === 128 && (h & 192) === 128) {
                                    c = (i & 15) << 18 | (a & 63) << 12 | (s & 63) << 6 | h & 63;
                                    if (c > 65535 && c < 1114112) {
                                        o = c;
                                    }
                                }
                        }
                    }
                    if (o === null) {
                        o = 65533;
                        u = 1;
                    } else if (o > 65535) {
                        o -= 65536;
                        f.push(o >>> 10 & 1023 | 55296);
                        o = 56320 | o & 1023;
                    }
                    f.push(o);
                    n += u;
                }
                return decodeCodePointsArray(f);
            }
            var u = 4096;
            function decodeCodePointsArray(e) {
                var r = e.length;
                if (r <= u) {
                    return String.fromCharCode.apply(String, e);
                }
                var t = "";
                var f = 0;
                while(f < r){
                    t += String.fromCharCode.apply(String, e.slice(f, f += u));
                }
                return t;
            }
            function asciiSlice(e, r, t) {
                var f = "";
                t = Math.min(e.length, t);
                for(var n = r; n < t; ++n){
                    f += String.fromCharCode(e[n] & 127);
                }
                return f;
            }
            function latin1Slice(e, r, t) {
                var f = "";
                t = Math.min(e.length, t);
                for(var n = r; n < t; ++n){
                    f += String.fromCharCode(e[n]);
                }
                return f;
            }
            function hexSlice(e, r, t) {
                var f = e.length;
                if (!r || r < 0) r = 0;
                if (!t || t < 0 || t > f) t = f;
                var n = "";
                for(var i = r; i < t; ++i){
                    n += s[e[i]];
                }
                return n;
            }
            function utf16leSlice(e, r, t) {
                var f = e.slice(r, t);
                var n = "";
                for(var i = 0; i < f.length; i += 2){
                    n += String.fromCharCode(f[i] + f[i + 1] * 256);
                }
                return n;
            }
            Buffer.prototype.slice = function slice(e, r) {
                var t = this.length;
                e = ~~e;
                r = r === undefined ? t : ~~r;
                if (e < 0) {
                    e += t;
                    if (e < 0) e = 0;
                } else if (e > t) {
                    e = t;
                }
                if (r < 0) {
                    r += t;
                    if (r < 0) r = 0;
                } else if (r > t) {
                    r = t;
                }
                if (r < e) r = e;
                var f = this.subarray(e, r);
                Object.setPrototypeOf(f, Buffer.prototype);
                return f;
            };
            function checkOffset(e, r, t) {
                if (e % 1 !== 0 || e < 0) throw new RangeError("offset is not uint");
                if (e + r > t) throw new RangeError("Trying to access beyond buffer length");
            }
            Buffer.prototype.readUIntLE = function readUIntLE(e, r, t) {
                e = e >>> 0;
                r = r >>> 0;
                if (!t) checkOffset(e, r, this.length);
                var f = this[e];
                var n = 1;
                var i = 0;
                while(++i < r && (n *= 256)){
                    f += this[e + i] * n;
                }
                return f;
            };
            Buffer.prototype.readUIntBE = function readUIntBE(e, r, t) {
                e = e >>> 0;
                r = r >>> 0;
                if (!t) {
                    checkOffset(e, r, this.length);
                }
                var f = this[e + --r];
                var n = 1;
                while(r > 0 && (n *= 256)){
                    f += this[e + --r] * n;
                }
                return f;
            };
            Buffer.prototype.readUInt8 = function readUInt8(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 1, this.length);
                return this[e];
            };
            Buffer.prototype.readUInt16LE = function readUInt16LE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 2, this.length);
                return this[e] | this[e + 1] << 8;
            };
            Buffer.prototype.readUInt16BE = function readUInt16BE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 2, this.length);
                return this[e] << 8 | this[e + 1];
            };
            Buffer.prototype.readUInt32LE = function readUInt32LE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 4, this.length);
                return (this[e] | this[e + 1] << 8 | this[e + 2] << 16) + this[e + 3] * 16777216;
            };
            Buffer.prototype.readUInt32BE = function readUInt32BE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 4, this.length);
                return this[e] * 16777216 + (this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]);
            };
            Buffer.prototype.readIntLE = function readIntLE(e, r, t) {
                e = e >>> 0;
                r = r >>> 0;
                if (!t) checkOffset(e, r, this.length);
                var f = this[e];
                var n = 1;
                var i = 0;
                while(++i < r && (n *= 256)){
                    f += this[e + i] * n;
                }
                n *= 128;
                if (f >= n) f -= Math.pow(2, 8 * r);
                return f;
            };
            Buffer.prototype.readIntBE = function readIntBE(e, r, t) {
                e = e >>> 0;
                r = r >>> 0;
                if (!t) checkOffset(e, r, this.length);
                var f = r;
                var n = 1;
                var i = this[e + --f];
                while(f > 0 && (n *= 256)){
                    i += this[e + --f] * n;
                }
                n *= 128;
                if (i >= n) i -= Math.pow(2, 8 * r);
                return i;
            };
            Buffer.prototype.readInt8 = function readInt8(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 1, this.length);
                if (!(this[e] & 128)) return this[e];
                return (255 - this[e] + 1) * -1;
            };
            Buffer.prototype.readInt16LE = function readInt16LE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 2, this.length);
                var t = this[e] | this[e + 1] << 8;
                return t & 32768 ? t | 4294901760 : t;
            };
            Buffer.prototype.readInt16BE = function readInt16BE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 2, this.length);
                var t = this[e + 1] | this[e] << 8;
                return t & 32768 ? t | 4294901760 : t;
            };
            Buffer.prototype.readInt32LE = function readInt32LE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 4, this.length);
                return this[e] | this[e + 1] << 8 | this[e + 2] << 16 | this[e + 3] << 24;
            };
            Buffer.prototype.readInt32BE = function readInt32BE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 4, this.length);
                return this[e] << 24 | this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3];
            };
            Buffer.prototype.readFloatLE = function readFloatLE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 4, this.length);
                return n.read(this, e, true, 23, 4);
            };
            Buffer.prototype.readFloatBE = function readFloatBE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 4, this.length);
                return n.read(this, e, false, 23, 4);
            };
            Buffer.prototype.readDoubleLE = function readDoubleLE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 8, this.length);
                return n.read(this, e, true, 52, 8);
            };
            Buffer.prototype.readDoubleBE = function readDoubleBE(e, r) {
                e = e >>> 0;
                if (!r) checkOffset(e, 8, this.length);
                return n.read(this, e, false, 52, 8);
            };
            function checkInt(e, r, t, f, n, i) {
                if (!Buffer.isBuffer(e)) throw new TypeError('"buffer" argument must be a Buffer instance');
                if (r > n || r < i) throw new RangeError('"value" argument is out of bounds');
                if (t + f > e.length) throw new RangeError("Index out of range");
            }
            Buffer.prototype.writeUIntLE = function writeUIntLE(e, r, t, f) {
                e = +e;
                r = r >>> 0;
                t = t >>> 0;
                if (!f) {
                    var n = Math.pow(2, 8 * t) - 1;
                    checkInt(this, e, r, t, n, 0);
                }
                var i = 1;
                var o = 0;
                this[r] = e & 255;
                while(++o < t && (i *= 256)){
                    this[r + o] = e / i & 255;
                }
                return r + t;
            };
            Buffer.prototype.writeUIntBE = function writeUIntBE(e, r, t, f) {
                e = +e;
                r = r >>> 0;
                t = t >>> 0;
                if (!f) {
                    var n = Math.pow(2, 8 * t) - 1;
                    checkInt(this, e, r, t, n, 0);
                }
                var i = t - 1;
                var o = 1;
                this[r + i] = e & 255;
                while(--i >= 0 && (o *= 256)){
                    this[r + i] = e / o & 255;
                }
                return r + t;
            };
            Buffer.prototype.writeUInt8 = function writeUInt8(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 1, 255, 0);
                this[r] = e & 255;
                return r + 1;
            };
            Buffer.prototype.writeUInt16LE = function writeUInt16LE(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 2, 65535, 0);
                this[r] = e & 255;
                this[r + 1] = e >>> 8;
                return r + 2;
            };
            Buffer.prototype.writeUInt16BE = function writeUInt16BE(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 2, 65535, 0);
                this[r] = e >>> 8;
                this[r + 1] = e & 255;
                return r + 2;
            };
            Buffer.prototype.writeUInt32LE = function writeUInt32LE(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 4, 4294967295, 0);
                this[r + 3] = e >>> 24;
                this[r + 2] = e >>> 16;
                this[r + 1] = e >>> 8;
                this[r] = e & 255;
                return r + 4;
            };
            Buffer.prototype.writeUInt32BE = function writeUInt32BE(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 4, 4294967295, 0);
                this[r] = e >>> 24;
                this[r + 1] = e >>> 16;
                this[r + 2] = e >>> 8;
                this[r + 3] = e & 255;
                return r + 4;
            };
            Buffer.prototype.writeIntLE = function writeIntLE(e, r, t, f) {
                e = +e;
                r = r >>> 0;
                if (!f) {
                    var n = Math.pow(2, 8 * t - 1);
                    checkInt(this, e, r, t, n - 1, -n);
                }
                var i = 0;
                var o = 1;
                var u = 0;
                this[r] = e & 255;
                while(++i < t && (o *= 256)){
                    if (e < 0 && u === 0 && this[r + i - 1] !== 0) {
                        u = 1;
                    }
                    this[r + i] = (e / o >> 0) - u & 255;
                }
                return r + t;
            };
            Buffer.prototype.writeIntBE = function writeIntBE(e, r, t, f) {
                e = +e;
                r = r >>> 0;
                if (!f) {
                    var n = Math.pow(2, 8 * t - 1);
                    checkInt(this, e, r, t, n - 1, -n);
                }
                var i = t - 1;
                var o = 1;
                var u = 0;
                this[r + i] = e & 255;
                while(--i >= 0 && (o *= 256)){
                    if (e < 0 && u === 0 && this[r + i + 1] !== 0) {
                        u = 1;
                    }
                    this[r + i] = (e / o >> 0) - u & 255;
                }
                return r + t;
            };
            Buffer.prototype.writeInt8 = function writeInt8(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 1, 127, -128);
                if (e < 0) e = 255 + e + 1;
                this[r] = e & 255;
                return r + 1;
            };
            Buffer.prototype.writeInt16LE = function writeInt16LE(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 2, 32767, -32768);
                this[r] = e & 255;
                this[r + 1] = e >>> 8;
                return r + 2;
            };
            Buffer.prototype.writeInt16BE = function writeInt16BE(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 2, 32767, -32768);
                this[r] = e >>> 8;
                this[r + 1] = e & 255;
                return r + 2;
            };
            Buffer.prototype.writeInt32LE = function writeInt32LE(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 4, 2147483647, -2147483648);
                this[r] = e & 255;
                this[r + 1] = e >>> 8;
                this[r + 2] = e >>> 16;
                this[r + 3] = e >>> 24;
                return r + 4;
            };
            Buffer.prototype.writeInt32BE = function writeInt32BE(e, r, t) {
                e = +e;
                r = r >>> 0;
                if (!t) checkInt(this, e, r, 4, 2147483647, -2147483648);
                if (e < 0) e = 4294967295 + e + 1;
                this[r] = e >>> 24;
                this[r + 1] = e >>> 16;
                this[r + 2] = e >>> 8;
                this[r + 3] = e & 255;
                return r + 4;
            };
            function checkIEEE754(e, r, t, f, n, i) {
                if (t + f > e.length) throw new RangeError("Index out of range");
                if (t < 0) throw new RangeError("Index out of range");
            }
            function writeFloat(e, r, t, f, i) {
                r = +r;
                t = t >>> 0;
                if (!i) {
                    checkIEEE754(e, r, t, 4, 34028234663852886e22, -34028234663852886e22);
                }
                n.write(e, r, t, f, 23, 4);
                return t + 4;
            }
            Buffer.prototype.writeFloatLE = function writeFloatLE(e, r, t) {
                return writeFloat(this, e, r, true, t);
            };
            Buffer.prototype.writeFloatBE = function writeFloatBE(e, r, t) {
                return writeFloat(this, e, r, false, t);
            };
            function writeDouble(e, r, t, f, i) {
                r = +r;
                t = t >>> 0;
                if (!i) {
                    checkIEEE754(e, r, t, 8, 17976931348623157e292, -17976931348623157e292);
                }
                n.write(e, r, t, f, 52, 8);
                return t + 8;
            }
            Buffer.prototype.writeDoubleLE = function writeDoubleLE(e, r, t) {
                return writeDouble(this, e, r, true, t);
            };
            Buffer.prototype.writeDoubleBE = function writeDoubleBE(e, r, t) {
                return writeDouble(this, e, r, false, t);
            };
            Buffer.prototype.copy = function copy(e, r, t, f) {
                if (!Buffer.isBuffer(e)) throw new TypeError("argument should be a Buffer");
                if (!t) t = 0;
                if (!f && f !== 0) f = this.length;
                if (r >= e.length) r = e.length;
                if (!r) r = 0;
                if (f > 0 && f < t) f = t;
                if (f === t) return 0;
                if (e.length === 0 || this.length === 0) return 0;
                if (r < 0) {
                    throw new RangeError("targetStart out of bounds");
                }
                if (t < 0 || t >= this.length) throw new RangeError("Index out of range");
                if (f < 0) throw new RangeError("sourceEnd out of bounds");
                if (f > this.length) f = this.length;
                if (e.length - r < f - t) {
                    f = e.length - r + t;
                }
                var n = f - t;
                if (this === e && typeof Uint8Array.prototype.copyWithin === "function") {
                    this.copyWithin(r, t, f);
                } else if (this === e && t < r && r < f) {
                    for(var i = n - 1; i >= 0; --i){
                        e[i + r] = this[i + t];
                    }
                } else {
                    Uint8Array.prototype.set.call(e, this.subarray(t, f), r);
                }
                return n;
            };
            Buffer.prototype.fill = function fill(e, r, t, f) {
                if (typeof e === "string") {
                    if (typeof r === "string") {
                        f = r;
                        r = 0;
                        t = this.length;
                    } else if (typeof t === "string") {
                        f = t;
                        t = this.length;
                    }
                    if (f !== undefined && typeof f !== "string") {
                        throw new TypeError("encoding must be a string");
                    }
                    if (typeof f === "string" && !Buffer.isEncoding(f)) {
                        throw new TypeError("Unknown encoding: " + f);
                    }
                    if (e.length === 1) {
                        var n = e.charCodeAt(0);
                        if (f === "utf8" && n < 128 || f === "latin1") {
                            e = n;
                        }
                    }
                } else if (typeof e === "number") {
                    e = e & 255;
                } else if (typeof e === "boolean") {
                    e = Number(e);
                }
                if (r < 0 || this.length < r || this.length < t) {
                    throw new RangeError("Out of range index");
                }
                if (t <= r) {
                    return this;
                }
                r = r >>> 0;
                t = t === undefined ? this.length : t >>> 0;
                if (!e) e = 0;
                var i;
                if (typeof e === "number") {
                    for(i = r; i < t; ++i){
                        this[i] = e;
                    }
                } else {
                    var o = Buffer.isBuffer(e) ? e : Buffer.from(e, f);
                    var u = o.length;
                    if (u === 0) {
                        throw new TypeError('The value "' + e + '" is invalid for argument "value"');
                    }
                    for(i = 0; i < t - r; ++i){
                        this[i + r] = o[i % u];
                    }
                }
                return this;
            };
            var a = /[^+/0-9A-Za-z-_]/g;
            function base64clean(e) {
                e = e.split("=")[0];
                e = e.trim().replace(a, "");
                if (e.length < 2) return "";
                while(e.length % 4 !== 0){
                    e = e + "=";
                }
                return e;
            }
            function utf8ToBytes(e, r) {
                r = r || Infinity;
                var t;
                var f = e.length;
                var n = null;
                var i = [];
                for(var o = 0; o < f; ++o){
                    t = e.charCodeAt(o);
                    if (t > 55295 && t < 57344) {
                        if (!n) {
                            if (t > 56319) {
                                if ((r -= 3) > -1) i.push(239, 191, 189);
                                continue;
                            } else if (o + 1 === f) {
                                if ((r -= 3) > -1) i.push(239, 191, 189);
                                continue;
                            }
                            n = t;
                            continue;
                        }
                        if (t < 56320) {
                            if ((r -= 3) > -1) i.push(239, 191, 189);
                            n = t;
                            continue;
                        }
                        t = (n - 55296 << 10 | t - 56320) + 65536;
                    } else if (n) {
                        if ((r -= 3) > -1) i.push(239, 191, 189);
                    }
                    n = null;
                    if (t < 128) {
                        if ((r -= 1) < 0) break;
                        i.push(t);
                    } else if (t < 2048) {
                        if ((r -= 2) < 0) break;
                        i.push(t >> 6 | 192, t & 63 | 128);
                    } else if (t < 65536) {
                        if ((r -= 3) < 0) break;
                        i.push(t >> 12 | 224, t >> 6 & 63 | 128, t & 63 | 128);
                    } else if (t < 1114112) {
                        if ((r -= 4) < 0) break;
                        i.push(t >> 18 | 240, t >> 12 & 63 | 128, t >> 6 & 63 | 128, t & 63 | 128);
                    } else {
                        throw new Error("Invalid code point");
                    }
                }
                return i;
            }
            function asciiToBytes(e) {
                var r = [];
                for(var t = 0; t < e.length; ++t){
                    r.push(e.charCodeAt(t) & 255);
                }
                return r;
            }
            function utf16leToBytes(e, r) {
                var t, f, n;
                var i = [];
                for(var o = 0; o < e.length; ++o){
                    if ((r -= 2) < 0) break;
                    t = e.charCodeAt(o);
                    f = t >> 8;
                    n = t % 256;
                    i.push(n);
                    i.push(f);
                }
                return i;
            }
            function base64ToBytes(e) {
                return f.toByteArray(base64clean(e));
            }
            function blitBuffer(e, r, t, f) {
                for(var n = 0; n < f; ++n){
                    if (n + t >= r.length || n >= e.length) break;
                    r[n + t] = e[n];
                }
                return n;
            }
            function isInstance(e, r) {
                return e instanceof r || e != null && e.constructor != null && e.constructor.name != null && e.constructor.name === r.name;
            }
            function numberIsNaN(e) {
                return e !== e;
            }
            var s = function() {
                var e = "0123456789abcdef";
                var r = new Array(256);
                for(var t = 0; t < 16; ++t){
                    var f = t * 16;
                    for(var n = 0; n < 16; ++n){
                        r[f + n] = e[t] + e[n];
                    }
                }
                return r;
            }();
        },
        783: function(e, r) {
            /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */ r.read = function(e, r, t, f, n) {
                var i, o;
                var u = n * 8 - f - 1;
                var a = (1 << u) - 1;
                var s = a >> 1;
                var h = -7;
                var c = t ? n - 1 : 0;
                var l = t ? -1 : 1;
                var p = e[r + c];
                c += l;
                i = p & (1 << -h) - 1;
                p >>= -h;
                h += u;
                for(; h > 0; i = i * 256 + e[r + c], c += l, h -= 8){}
                o = i & (1 << -h) - 1;
                i >>= -h;
                h += f;
                for(; h > 0; o = o * 256 + e[r + c], c += l, h -= 8){}
                if (i === 0) {
                    i = 1 - s;
                } else if (i === a) {
                    return o ? NaN : (p ? -1 : 1) * Infinity;
                } else {
                    o = o + Math.pow(2, f);
                    i = i - s;
                }
                return (p ? -1 : 1) * o * Math.pow(2, i - f);
            };
            r.write = function(e, r, t, f, n, i) {
                var o, u, a;
                var s = i * 8 - n - 1;
                var h = (1 << s) - 1;
                var c = h >> 1;
                var l = n === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
                var p = f ? 0 : i - 1;
                var y = f ? 1 : -1;
                var g = r < 0 || r === 0 && 1 / r < 0 ? 1 : 0;
                r = Math.abs(r);
                if (isNaN(r) || r === Infinity) {
                    u = isNaN(r) ? 1 : 0;
                    o = h;
                } else {
                    o = Math.floor(Math.log(r) / Math.LN2);
                    if (r * (a = Math.pow(2, -o)) < 1) {
                        o--;
                        a *= 2;
                    }
                    if (o + c >= 1) {
                        r += l / a;
                    } else {
                        r += l * Math.pow(2, 1 - c);
                    }
                    if (r * a >= 2) {
                        o++;
                        a /= 2;
                    }
                    if (o + c >= h) {
                        u = 0;
                        o = h;
                    } else if (o + c >= 1) {
                        u = (r * a - 1) * Math.pow(2, n);
                        o = o + c;
                    } else {
                        u = r * Math.pow(2, c - 1) * Math.pow(2, n);
                        o = 0;
                    }
                }
                for(; n >= 8; e[t + p] = u & 255, p += y, u /= 256, n -= 8){}
                o = o << n | u;
                s += n;
                for(; s > 0; e[t + p] = o & 255, p += y, o /= 256, s -= 8){}
                e[t + p - y] |= g * 128;
            };
        }
    };
    var r = {};
    function __nccwpck_require__(t) {
        var f = r[t];
        if (f !== undefined) {
            return f.exports;
        }
        var n = r[t] = {
            exports: {}
        };
        var i = true;
        try {
            e[t](n, n.exports, __nccwpck_require__);
            i = false;
        } finally{
            if (i) delete r[t];
        }
        return n.exports;
    }
    if (typeof __nccwpck_require__ !== "undefined") __nccwpck_require__.ab = __dirname + "/";
    var t = __nccwpck_require__(72);
    module.exports = t;
})();
}}),
"[project]/node_modules/family/lib/index-DD_kndDs.js [app-client] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "i": (()=>index$1)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/compiled/buffer/index.js [app-client] (ecmascript)");
function _mergeNamespaces(n, m) {
    m.forEach(function(e) {
        e && typeof e !== 'string' && !Array.isArray(e) && Object.keys(e).forEach(function(k) {
            if (k !== 'default' && !(k in n)) {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function() {
                        return e[k];
                    }
                });
            }
        });
    });
    return Object.freeze(n);
}
var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};
function getDefaultExportFromCjs(x) {
    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}
var postRobot$1 = {
    exports: {}
};
var postRobot = {
    exports: {}
};
(function(module, exports) {
    !function(root, factory) {
        module.exports = factory();
    }("undefined" != typeof self ? self : commonjsGlobal, function() {
        return function(modules) {
            var installedModules = {};
            function __webpack_require__(moduleId) {
                if (installedModules[moduleId]) return installedModules[moduleId].exports;
                var module = installedModules[moduleId] = {
                    i: moduleId,
                    l: !1,
                    exports: {}
                };
                modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
                module.l = !0;
                return module.exports;
            }
            __webpack_require__.m = modules;
            __webpack_require__.c = installedModules;
            __webpack_require__.d = function(exports, name, getter) {
                __webpack_require__.o(exports, name) || Object.defineProperty(exports, name, {
                    enumerable: !0,
                    get: getter
                });
            };
            __webpack_require__.r = function(exports) {
                "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(exports, Symbol.toStringTag, {
                    value: "Module"
                });
                Object.defineProperty(exports, "__esModule", {
                    value: !0
                });
            };
            __webpack_require__.t = function(value, mode) {
                1 & mode && (value = __webpack_require__(value));
                if (8 & mode) return value;
                if (4 & mode && "object" == typeof value && value && value.__esModule) return value;
                var ns = Object.create(null);
                __webpack_require__.r(ns);
                Object.defineProperty(ns, "default", {
                    enumerable: !0,
                    value: value
                });
                if (2 & mode && "string" != typeof value) for(var key in value)__webpack_require__.d(ns, key, (function(key) {
                    return value[key];
                }).bind(null, key));
                return ns;
            };
            __webpack_require__.n = function(module) {
                var getter = module && module.__esModule ? function() {
                    return module.default;
                } : function() {
                    return module;
                };
                __webpack_require__.d(getter, "a", getter);
                return getter;
            };
            __webpack_require__.o = function(object, property) {
                return ({}).hasOwnProperty.call(object, property);
            };
            __webpack_require__.p = "";
            return __webpack_require__(__webpack_require__.s = 0);
        }([
            function(module, __webpack_exports__, __webpack_require__) {
                __webpack_require__.r(__webpack_exports__);
                __webpack_require__.d(__webpack_exports__, "Promise", function() {
                    return promise_ZalgoPromise;
                });
                __webpack_require__.d(__webpack_exports__, "TYPES", function() {
                    return src_types_TYPES_0;
                });
                __webpack_require__.d(__webpack_exports__, "ProxyWindow", function() {
                    return window_ProxyWindow;
                });
                __webpack_require__.d(__webpack_exports__, "setup", function() {
                    return setup;
                });
                __webpack_require__.d(__webpack_exports__, "destroy", function() {
                    return destroy;
                });
                __webpack_require__.d(__webpack_exports__, "serializeMessage", function() {
                    return setup_serializeMessage;
                });
                __webpack_require__.d(__webpack_exports__, "deserializeMessage", function() {
                    return setup_deserializeMessage;
                });
                __webpack_require__.d(__webpack_exports__, "createProxyWindow", function() {
                    return createProxyWindow;
                });
                __webpack_require__.d(__webpack_exports__, "toProxyWindow", function() {
                    return setup_toProxyWindow;
                });
                __webpack_require__.d(__webpack_exports__, "on", function() {
                    return on_on;
                });
                __webpack_require__.d(__webpack_exports__, "once", function() {
                    return on_once;
                });
                __webpack_require__.d(__webpack_exports__, "send", function() {
                    return send_send;
                });
                __webpack_require__.d(__webpack_exports__, "markWindowKnown", function() {
                    return markWindowKnown;
                });
                __webpack_require__.d(__webpack_exports__, "cleanUpWindow", function() {
                    return cleanUpWindow;
                });
                __webpack_require__.d(__webpack_exports__, "bridge", function() {});
                function isRegex(item) {
                    return "[object RegExp]" === ({}).toString.call(item);
                }
                var IE_WIN_ACCESS_ERROR = "Call was rejected by callee.\r\n";
                function getActualProtocol(win) {
                    void 0 === win && (win = window);
                    return win.location.protocol;
                }
                function getProtocol(win) {
                    void 0 === win && (win = window);
                    if (win.mockDomain) {
                        var protocol = win.mockDomain.split("//")[0];
                        if (protocol) return protocol;
                    }
                    return getActualProtocol(win);
                }
                function isAboutProtocol(win) {
                    void 0 === win && (win = window);
                    return "about:" === getProtocol(win);
                }
                function getParent(win) {
                    void 0 === win && (win = window);
                    if (win) try {
                        if (win.parent && win.parent !== win) return win.parent;
                    } catch (err) {}
                }
                function getOpener(win) {
                    void 0 === win && (win = window);
                    if (win && !getParent(win)) try {
                        return win.opener;
                    } catch (err) {}
                }
                function canReadFromWindow(win) {
                    try {
                        return !0;
                    } catch (err) {}
                    return !1;
                }
                function getActualDomain(win) {
                    void 0 === win && (win = window);
                    var location = win.location;
                    if (!location) throw new Error("Can not read window location");
                    var protocol = getActualProtocol(win);
                    if (!protocol) throw new Error("Can not read window protocol");
                    if ("file:" === protocol) return "file://";
                    if ("about:" === protocol) {
                        var parent = getParent(win);
                        return parent && canReadFromWindow() ? getActualDomain(parent) : "about://";
                    }
                    var host = location.host;
                    if (!host) throw new Error("Can not read window host");
                    return protocol + "//" + host;
                }
                function getDomain(win) {
                    void 0 === win && (win = window);
                    var domain = getActualDomain(win);
                    return domain && win.mockDomain && 0 === win.mockDomain.indexOf("mock:") ? win.mockDomain : domain;
                }
                function isSameDomain(win) {
                    if (!function(win) {
                        try {
                            if (win === window) return !0;
                        } catch (err) {}
                        try {
                            var desc = Object.getOwnPropertyDescriptor(win, "location");
                            if (desc && !1 === desc.enumerable) return !1;
                        } catch (err) {}
                        try {
                            if (isAboutProtocol(win) && canReadFromWindow()) return !0;
                        } catch (err) {}
                        try {
                            if (function(win) {
                                void 0 === win && (win = window);
                                return "mock:" === getProtocol(win);
                            }(win) && canReadFromWindow()) return !0;
                        } catch (err) {}
                        try {
                            if (getActualDomain(win) === getActualDomain(window)) return !0;
                        } catch (err) {}
                        return !1;
                    }(win)) return !1;
                    try {
                        if (win === window) return !0;
                        if (isAboutProtocol(win) && canReadFromWindow()) return !0;
                        if (getDomain(window) === getDomain(win)) return !0;
                    } catch (err) {}
                    return !1;
                }
                function assertSameDomain(win) {
                    if (!isSameDomain(win)) throw new Error("Expected window to be same domain");
                    return win;
                }
                function isAncestorParent(parent, child) {
                    if (!parent || !child) return !1;
                    var childParent = getParent(child);
                    return childParent ? childParent === parent : -1 !== (function(win) {
                        var result = [];
                        try {
                            for(; win.parent !== win;){
                                result.push(win.parent);
                                win = win.parent;
                            }
                        } catch (err) {}
                        return result;
                    })(child).indexOf(parent);
                }
                function getFrames(win) {
                    var result = [];
                    var frames;
                    try {
                        frames = win.frames;
                    } catch (err) {
                        frames = win;
                    }
                    var len;
                    try {
                        len = frames.length;
                    } catch (err) {}
                    if (0 === len) return result;
                    if (len) {
                        for(var i = 0; i < len; i++){
                            var frame = void 0;
                            try {
                                frame = frames[i];
                            } catch (err) {
                                continue;
                            }
                            result.push(frame);
                        }
                        return result;
                    }
                    for(var _i = 0; _i < 100; _i++){
                        var _frame = void 0;
                        try {
                            _frame = frames[_i];
                        } catch (err) {
                            return result;
                        }
                        if (!_frame) return result;
                        result.push(_frame);
                    }
                    return result;
                }
                var iframeWindows = [];
                var iframeFrames = [];
                function isWindowClosed(win, allowMock) {
                    void 0 === allowMock && (allowMock = !0);
                    try {
                        if (win === window) return !1;
                    } catch (err) {
                        return !0;
                    }
                    try {
                        if (!win) return !0;
                    } catch (err) {
                        return !0;
                    }
                    try {
                        if (win.closed) return !0;
                    } catch (err) {
                        return !err || err.message !== IE_WIN_ACCESS_ERROR;
                    }
                    if (allowMock && isSameDomain(win)) try {
                        if (win.mockclosed) return !0;
                    } catch (err) {}
                    try {
                        if (!win.parent || !win.top) return !0;
                    } catch (err) {}
                    var iframeIndex = function(collection, item) {
                        for(var i = 0; i < collection.length; i++)try {
                            if (collection[i] === item) return i;
                        } catch (err) {}
                        return -1;
                    }(iframeWindows, win);
                    if (-1 !== iframeIndex) {
                        var frame = iframeFrames[iframeIndex];
                        if (frame && function(frame) {
                            if (!frame.contentWindow) return !0;
                            if (!frame.parentNode) return !0;
                            var doc = frame.ownerDocument;
                            if (doc && doc.documentElement && !doc.documentElement.contains(frame)) {
                                var parent = frame;
                                for(; parent.parentNode && parent.parentNode !== parent;)parent = parent.parentNode;
                                if (!parent.host || !doc.documentElement.contains(parent.host)) return !0;
                            }
                            return !1;
                        }(frame)) return !0;
                    }
                    return !1;
                }
                function getAncestor(win) {
                    void 0 === win && (win = window);
                    return getOpener(win = win || window) || getParent(win) || void 0;
                }
                function matchDomain(pattern, origin) {
                    if ("string" == typeof pattern) {
                        if ("string" == typeof origin) return "*" === pattern || origin === pattern;
                        if (isRegex(origin)) return !1;
                        if (Array.isArray(origin)) return !1;
                    }
                    return isRegex(pattern) ? isRegex(origin) ? pattern.toString() === origin.toString() : !Array.isArray(origin) && Boolean(origin.match(pattern)) : !!Array.isArray(pattern) && (Array.isArray(origin) ? JSON.stringify(pattern) === JSON.stringify(origin) : !isRegex(origin) && pattern.some(function(subpattern) {
                        return matchDomain(subpattern, origin);
                    }));
                }
                function isWindow(obj) {
                    try {
                        if (obj === window) return !0;
                    } catch (err) {
                        if (err && err.message === IE_WIN_ACCESS_ERROR) return !0;
                    }
                    try {
                        if ("[object Window]" === ({}).toString.call(obj)) return !0;
                    } catch (err) {
                        if (err && err.message === IE_WIN_ACCESS_ERROR) return !0;
                    }
                    try {
                        if (window.Window && obj instanceof window.Window) return !0;
                    } catch (err) {
                        if (err && err.message === IE_WIN_ACCESS_ERROR) return !0;
                    }
                    try {
                        if (obj && obj.self === obj) return !0;
                    } catch (err) {
                        if (err && err.message === IE_WIN_ACCESS_ERROR) return !0;
                    }
                    try {
                        if (obj && obj.parent === obj) return !0;
                    } catch (err) {
                        if (err && err.message === IE_WIN_ACCESS_ERROR) return !0;
                    }
                    try {
                        if (obj && obj.top === obj) return !0;
                    } catch (err) {
                        if (err && err.message === IE_WIN_ACCESS_ERROR) return !0;
                    }
                    try {
                        if (obj && "__unlikely_value__" === obj.__cross_domain_utils_window_check__) return !1;
                    } catch (err) {
                        return !0;
                    }
                    try {
                        if ("postMessage" in obj && "self" in obj && "location" in obj) return !0;
                    } catch (err) {}
                    return !1;
                }
                function getFrameForWindow(win) {
                    if (isSameDomain(win)) return assertSameDomain(win).frameElement;
                    for(var _i21 = 0, _document$querySelect2 = document.querySelectorAll("iframe"); _i21 < _document$querySelect2.length; _i21++){
                        var frame = _document$querySelect2[_i21];
                        if (frame && frame.contentWindow && frame.contentWindow === win) return frame;
                    }
                }
                function closeWindow(win) {
                    if (function(win) {
                        void 0 === win && (win = window);
                        return Boolean(getParent(win));
                    }(win)) {
                        var frame = getFrameForWindow(win);
                        if (frame && frame.parentElement) {
                            frame.parentElement.removeChild(frame);
                            return;
                        }
                    }
                    try {
                        win.close();
                    } catch (err) {}
                }
                function utils_isPromise(item) {
                    try {
                        if (!item) return !1;
                        if ("undefined" != typeof Promise && item instanceof Promise) return !0;
                        if ("undefined" != typeof window && "function" == typeof window.Window && item instanceof window.Window) return !1;
                        if ("undefined" != typeof window && "function" == typeof window.constructor && item instanceof window.constructor) return !1;
                        var _toString = {}.toString;
                        if (_toString) {
                            var name = _toString.call(item);
                            if ("[object Window]" === name || "[object global]" === name || "[object DOMWindow]" === name) return !1;
                        }
                        if ("function" == typeof item.then) return !0;
                    } catch (err) {
                        return !1;
                    }
                    return !1;
                }
                var dispatchedErrors = [];
                var possiblyUnhandledPromiseHandlers = [];
                var activeCount = 0;
                var flushPromise;
                function flushActive() {
                    if (!activeCount && flushPromise) {
                        var promise = flushPromise;
                        flushPromise = null;
                        promise.resolve();
                    }
                }
                function startActive() {
                    activeCount += 1;
                }
                function endActive() {
                    activeCount -= 1;
                    flushActive();
                }
                var promise_ZalgoPromise = function() {
                    function ZalgoPromise(handler) {
                        var _this = this;
                        this.resolved = void 0;
                        this.rejected = void 0;
                        this.errorHandled = void 0;
                        this.value = void 0;
                        this.error = void 0;
                        this.handlers = void 0;
                        this.dispatching = void 0;
                        this.stack = void 0;
                        this.resolved = !1;
                        this.rejected = !1;
                        this.errorHandled = !1;
                        this.handlers = [];
                        if (handler) {
                            var _result;
                            var _error;
                            var resolved = !1;
                            var rejected = !1;
                            var isAsync = !1;
                            startActive();
                            try {
                                handler(function(res) {
                                    if (isAsync) _this.resolve(res);
                                    else {
                                        resolved = !0;
                                        _result = res;
                                    }
                                }, function(err) {
                                    if (isAsync) _this.reject(err);
                                    else {
                                        rejected = !0;
                                        _error = err;
                                    }
                                });
                            } catch (err) {
                                endActive();
                                this.reject(err);
                                return;
                            }
                            endActive();
                            isAsync = !0;
                            resolved ? this.resolve(_result) : rejected && this.reject(_error);
                        }
                    }
                    var _proto = ZalgoPromise.prototype;
                    _proto.resolve = function(result) {
                        if (this.resolved || this.rejected) return this;
                        if (utils_isPromise(result)) throw new Error("Can not resolve promise with another promise");
                        this.resolved = !0;
                        this.value = result;
                        this.dispatch();
                        return this;
                    };
                    _proto.reject = function(error) {
                        var _this2 = this;
                        if (this.resolved || this.rejected) return this;
                        if (utils_isPromise(error)) throw new Error("Can not reject promise with another promise");
                        if (!error) {
                            var _err = error && "function" == typeof error.toString ? error.toString() : ({}).toString.call(error);
                            error = new Error("Expected reject to be called with Error, got " + _err);
                        }
                        this.rejected = !0;
                        this.error = error;
                        this.errorHandled || setTimeout(function() {
                            _this2.errorHandled || function(err, promise) {
                                if (-1 === dispatchedErrors.indexOf(err)) {
                                    dispatchedErrors.push(err);
                                    setTimeout(function() {
                                        throw err;
                                    }, 1);
                                    for(var j = 0; j < possiblyUnhandledPromiseHandlers.length; j++)possiblyUnhandledPromiseHandlers[j](err, promise);
                                }
                            }(error, _this2);
                        }, 1);
                        this.dispatch();
                        return this;
                    };
                    _proto.asyncReject = function(error) {
                        this.errorHandled = !0;
                        this.reject(error);
                        return this;
                    };
                    _proto.dispatch = function() {
                        var resolved = this.resolved, rejected = this.rejected, handlers = this.handlers;
                        if (!this.dispatching && (resolved || rejected)) {
                            this.dispatching = !0;
                            startActive();
                            var chain = function(firstPromise, secondPromise) {
                                return firstPromise.then(function(res) {
                                    secondPromise.resolve(res);
                                }, function(err) {
                                    secondPromise.reject(err);
                                });
                            };
                            for(var i = 0; i < handlers.length; i++){
                                var _handlers$i = handlers[i], onSuccess = _handlers$i.onSuccess, onError = _handlers$i.onError, promise = _handlers$i.promise;
                                var _result2 = void 0;
                                if (resolved) try {
                                    _result2 = onSuccess ? onSuccess(this.value) : this.value;
                                } catch (err) {
                                    promise.reject(err);
                                    continue;
                                }
                                else if (rejected) {
                                    if (!onError) {
                                        promise.reject(this.error);
                                        continue;
                                    }
                                    try {
                                        _result2 = onError(this.error);
                                    } catch (err) {
                                        promise.reject(err);
                                        continue;
                                    }
                                }
                                if (_result2 instanceof ZalgoPromise && (_result2.resolved || _result2.rejected)) {
                                    var promiseResult = _result2;
                                    promiseResult.resolved ? promise.resolve(promiseResult.value) : promise.reject(promiseResult.error);
                                    promiseResult.errorHandled = !0;
                                } else utils_isPromise(_result2) ? _result2 instanceof ZalgoPromise && (_result2.resolved || _result2.rejected) ? _result2.resolved ? promise.resolve(_result2.value) : promise.reject(_result2.error) : chain(_result2, promise) : promise.resolve(_result2);
                            }
                            handlers.length = 0;
                            this.dispatching = !1;
                            endActive();
                        }
                    };
                    _proto.then = function(onSuccess, onError) {
                        if (onSuccess && "function" != typeof onSuccess && !onSuccess.call) throw new Error("Promise.then expected a function for success handler");
                        if (onError && "function" != typeof onError && !onError.call) throw new Error("Promise.then expected a function for error handler");
                        var promise = new ZalgoPromise;
                        this.handlers.push({
                            promise: promise,
                            onSuccess: onSuccess,
                            onError: onError
                        });
                        this.errorHandled = !0;
                        this.dispatch();
                        return promise;
                    };
                    _proto.catch = function(onError) {
                        return this.then(void 0, onError);
                    };
                    _proto.finally = function(onFinally) {
                        if (onFinally && "function" != typeof onFinally && !onFinally.call) throw new Error("Promise.finally expected a function");
                        return this.then(function(result) {
                            return ZalgoPromise.try(onFinally).then(function() {
                                return result;
                            });
                        }, function(err) {
                            return ZalgoPromise.try(onFinally).then(function() {
                                throw err;
                            });
                        });
                    };
                    _proto.timeout = function(time, err) {
                        var _this3 = this;
                        if (this.resolved || this.rejected) return this;
                        var timeout = setTimeout(function() {
                            _this3.resolved || _this3.rejected || _this3.reject(err || new Error("Promise timed out after " + time + "ms"));
                        }, time);
                        return this.then(function(result) {
                            clearTimeout(timeout);
                            return result;
                        });
                    };
                    _proto.toPromise = function() {
                        if ("undefined" == typeof Promise) throw new TypeError("Could not find Promise");
                        return Promise.resolve(this);
                    };
                    _proto.lazy = function() {
                        this.errorHandled = !0;
                        return this;
                    };
                    ZalgoPromise.resolve = function(value) {
                        return value instanceof ZalgoPromise ? value : utils_isPromise(value) ? new ZalgoPromise(function(resolve, reject) {
                            return value.then(resolve, reject);
                        }) : (new ZalgoPromise).resolve(value);
                    };
                    ZalgoPromise.reject = function(error) {
                        return (new ZalgoPromise).reject(error);
                    };
                    ZalgoPromise.asyncReject = function(error) {
                        return (new ZalgoPromise).asyncReject(error);
                    };
                    ZalgoPromise.all = function(promises) {
                        var promise = new ZalgoPromise;
                        var count = promises.length;
                        var results = [].slice();
                        if (!count) {
                            promise.resolve(results);
                            return promise;
                        }
                        var chain = function(i, firstPromise, secondPromise) {
                            return firstPromise.then(function(res) {
                                results[i] = res;
                                0 == (count -= 1) && promise.resolve(results);
                            }, function(err) {
                                secondPromise.reject(err);
                            });
                        };
                        for(var i = 0; i < promises.length; i++){
                            var prom = promises[i];
                            if (prom instanceof ZalgoPromise) {
                                if (prom.resolved) {
                                    results[i] = prom.value;
                                    count -= 1;
                                    continue;
                                }
                            } else if (!utils_isPromise(prom)) {
                                results[i] = prom;
                                count -= 1;
                                continue;
                            }
                            chain(i, ZalgoPromise.resolve(prom), promise);
                        }
                        0 === count && promise.resolve(results);
                        return promise;
                    };
                    ZalgoPromise.hash = function(promises) {
                        var result = {};
                        var awaitPromises = [];
                        var _loop = function(key) {
                            if (promises.hasOwnProperty(key)) {
                                var value = promises[key];
                                utils_isPromise(value) ? awaitPromises.push(value.then(function(res) {
                                    result[key] = res;
                                })) : result[key] = value;
                            }
                        };
                        for(var key in promises)_loop(key);
                        return ZalgoPromise.all(awaitPromises).then(function() {
                            return result;
                        });
                    };
                    ZalgoPromise.map = function(items, method) {
                        return ZalgoPromise.all(items.map(method));
                    };
                    ZalgoPromise.onPossiblyUnhandledException = function(handler) {
                        return function(handler) {
                            possiblyUnhandledPromiseHandlers.push(handler);
                            return {
                                cancel: function() {
                                    possiblyUnhandledPromiseHandlers.splice(possiblyUnhandledPromiseHandlers.indexOf(handler), 1);
                                }
                            };
                        }(handler);
                    };
                    ZalgoPromise.try = function(method, context, args) {
                        if (method && "function" != typeof method && !method.call) throw new Error("Promise.try expected a function");
                        var result;
                        startActive();
                        try {
                            result = method.apply(context, args || []);
                        } catch (err) {
                            endActive();
                            return ZalgoPromise.reject(err);
                        }
                        endActive();
                        return ZalgoPromise.resolve(result);
                    };
                    ZalgoPromise.delay = function(_delay) {
                        return new ZalgoPromise(function(resolve) {
                            setTimeout(resolve, _delay);
                        });
                    };
                    ZalgoPromise.isPromise = function(value) {
                        return !!(value && value instanceof ZalgoPromise) || utils_isPromise(value);
                    };
                    ZalgoPromise.flush = function() {
                        return function(Zalgo) {
                            var promise = flushPromise = flushPromise || new Zalgo;
                            flushActive();
                            return promise;
                        }(ZalgoPromise);
                    };
                    return ZalgoPromise;
                }();
                function util_safeIndexOf(collection, item) {
                    for(var i = 0; i < collection.length; i++)try {
                        if (collection[i] === item) return i;
                    } catch (err) {}
                    return -1;
                }
                var weakmap_CrossDomainSafeWeakMap = function() {
                    function CrossDomainSafeWeakMap() {
                        this.name = void 0;
                        this.weakmap = void 0;
                        this.keys = void 0;
                        this.values = void 0;
                        this.name = "__weakmap_" + (1e9 * Math.random() >>> 0) + "__";
                        if (function() {
                            if ("undefined" == typeof WeakMap) return !1;
                            if (void 0 === Object.freeze) return !1;
                            try {
                                var testWeakMap = new WeakMap;
                                var testKey = {};
                                Object.freeze(testKey);
                                testWeakMap.set(testKey, "__testvalue__");
                                return "__testvalue__" === testWeakMap.get(testKey);
                            } catch (err) {
                                return !1;
                            }
                        }()) try {
                            this.weakmap = new WeakMap;
                        } catch (err) {}
                        this.keys = [];
                        this.values = [];
                    }
                    var _proto = CrossDomainSafeWeakMap.prototype;
                    _proto._cleanupClosedWindows = function() {
                        var weakmap = this.weakmap;
                        var keys = this.keys;
                        for(var i = 0; i < keys.length; i++){
                            var value = keys[i];
                            if (isWindow(value) && isWindowClosed(value)) {
                                if (weakmap) try {
                                    weakmap.delete(value);
                                } catch (err) {}
                                keys.splice(i, 1);
                                this.values.splice(i, 1);
                                i -= 1;
                            }
                        }
                    };
                    _proto.isSafeToReadWrite = function(key) {
                        return !isWindow(key);
                    };
                    _proto.set = function(key, value) {
                        if (!key) throw new Error("WeakMap expected key");
                        var weakmap = this.weakmap;
                        if (weakmap) try {
                            weakmap.set(key, value);
                        } catch (err) {
                            delete this.weakmap;
                        }
                        if (this.isSafeToReadWrite(key)) try {
                            var name = this.name;
                            var entry = key[name];
                            entry && entry[0] === key ? entry[1] = value : Object.defineProperty(key, name, {
                                value: [
                                    key,
                                    value
                                ],
                                writable: !0
                            });
                            return;
                        } catch (err) {}
                        this._cleanupClosedWindows();
                        var keys = this.keys;
                        var values = this.values;
                        var index = util_safeIndexOf(keys, key);
                        if (-1 === index) {
                            keys.push(key);
                            values.push(value);
                        } else values[index] = value;
                    };
                    _proto.get = function(key) {
                        if (!key) throw new Error("WeakMap expected key");
                        var weakmap = this.weakmap;
                        if (weakmap) try {
                            if (weakmap.has(key)) return weakmap.get(key);
                        } catch (err) {
                            delete this.weakmap;
                        }
                        if (this.isSafeToReadWrite(key)) try {
                            var entry = key[this.name];
                            return entry && entry[0] === key ? entry[1] : void 0;
                        } catch (err) {}
                        this._cleanupClosedWindows();
                        var index = util_safeIndexOf(this.keys, key);
                        if (-1 !== index) return this.values[index];
                    };
                    _proto.delete = function(key) {
                        if (!key) throw new Error("WeakMap expected key");
                        var weakmap = this.weakmap;
                        if (weakmap) try {
                            weakmap.delete(key);
                        } catch (err) {
                            delete this.weakmap;
                        }
                        if (this.isSafeToReadWrite(key)) try {
                            var entry = key[this.name];
                            entry && entry[0] === key && (entry[0] = entry[1] = void 0);
                        } catch (err) {}
                        this._cleanupClosedWindows();
                        var keys = this.keys;
                        var index = util_safeIndexOf(keys, key);
                        if (-1 !== index) {
                            keys.splice(index, 1);
                            this.values.splice(index, 1);
                        }
                    };
                    _proto.has = function(key) {
                        if (!key) throw new Error("WeakMap expected key");
                        var weakmap = this.weakmap;
                        if (weakmap) try {
                            if (weakmap.has(key)) return !0;
                        } catch (err) {
                            delete this.weakmap;
                        }
                        if (this.isSafeToReadWrite(key)) try {
                            var entry = key[this.name];
                            return !(!entry || entry[0] !== key);
                        } catch (err) {}
                        this._cleanupClosedWindows();
                        return -1 !== util_safeIndexOf(this.keys, key);
                    };
                    _proto.getOrSet = function(key, getter) {
                        if (this.has(key)) return this.get(key);
                        var value = getter();
                        this.set(key, value);
                        return value;
                    };
                    return CrossDomainSafeWeakMap;
                }();
                function getFunctionName(fn) {
                    return fn.name || fn.__name__ || fn.displayName || "anonymous";
                }
                function setFunctionName(fn, name) {
                    try {
                        delete fn.name;
                        fn.name = name;
                    } catch (err) {}
                    fn.__name__ = fn.displayName = name;
                    return fn;
                }
                function uniqueID() {
                    var chars = "0123456789abcdef";
                    return "uid_" + "xxxxxxxxxx".replace(/./g, function() {
                        return chars.charAt(Math.floor(Math.random() * chars.length));
                    }) + "_" + (function(str) {
                        if ("function" == typeof btoa) return btoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, function(m, p1) {
                            return String.fromCharCode(parseInt(p1, 16));
                        })).replace(/[=]/g, "");
                        if ("undefined" != typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"]) return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$compiled$2f$buffer$2f$index$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__["Buffer"].from(str, "utf8").toString("base64").replace(/[=]/g, "");
                        throw new Error("Can not find window.btoa or Buffer");
                    })((new Date).toISOString().slice(11, 19).replace("T", ".")).replace(/[^a-zA-Z0-9]/g, "").toLowerCase();
                }
                var objectIDs;
                function serializeArgs(args) {
                    try {
                        return JSON.stringify([].slice.call(args), function(subkey, val) {
                            return "function" == typeof val ? "memoize[" + function(obj) {
                                objectIDs = objectIDs || new weakmap_CrossDomainSafeWeakMap;
                                if (null == obj || "object" != typeof obj && "function" != typeof obj) throw new Error("Invalid object");
                                var uid = objectIDs.get(obj);
                                if (!uid) {
                                    uid = typeof obj + ":" + uniqueID();
                                    objectIDs.set(obj, uid);
                                }
                                return uid;
                            }(val) + "]" : "undefined" != typeof window && val instanceof window.Element || null !== val && "object" == typeof val && 1 === val.nodeType && "object" == typeof val.style && "object" == typeof val.ownerDocument ? {} : val;
                        });
                    } catch (err) {
                        throw new Error("Arguments not serializable -- can not be used to memoize");
                    }
                }
                function getEmptyObject() {
                    return {};
                }
                var memoizeGlobalIndex = 0;
                var memoizeGlobalIndexValidFrom = 0;
                function memoize(method, options) {
                    void 0 === options && (options = {});
                    var _options$thisNamespac = options.thisNamespace, thisNamespace = void 0 !== _options$thisNamespac && _options$thisNamespac, cacheTime = options.time;
                    var simpleCache;
                    var thisCache;
                    var memoizeIndex = memoizeGlobalIndex;
                    memoizeGlobalIndex += 1;
                    var memoizedFunction = function() {
                        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)args[_key] = arguments[_key];
                        if (memoizeIndex < memoizeGlobalIndexValidFrom) {
                            simpleCache = null;
                            thisCache = null;
                            memoizeIndex = memoizeGlobalIndex;
                            memoizeGlobalIndex += 1;
                        }
                        var cache;
                        cache = thisNamespace ? (thisCache = thisCache || new weakmap_CrossDomainSafeWeakMap).getOrSet(this, getEmptyObject) : simpleCache = simpleCache || {};
                        var cacheKey;
                        try {
                            cacheKey = serializeArgs(args);
                        } catch (_unused) {
                            return method.apply(this, arguments);
                        }
                        var cacheResult = cache[cacheKey];
                        if (cacheResult && cacheTime && Date.now() - cacheResult.time < cacheTime) {
                            delete cache[cacheKey];
                            cacheResult = null;
                        }
                        if (cacheResult) return cacheResult.value;
                        var time = Date.now();
                        var value = method.apply(this, arguments);
                        cache[cacheKey] = {
                            time: time,
                            value: value
                        };
                        return value;
                    };
                    memoizedFunction.reset = function() {
                        simpleCache = null;
                        thisCache = null;
                    };
                    return setFunctionName(memoizedFunction, (options.name || getFunctionName(method)) + "::memoized");
                }
                memoize.clear = function() {
                    memoizeGlobalIndexValidFrom = memoizeGlobalIndex;
                };
                function memoizePromise(method) {
                    var cache = {};
                    function memoizedPromiseFunction() {
                        var _arguments = arguments, _this = this;
                        for(var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++)args[_key2] = arguments[_key2];
                        var key = serializeArgs(args);
                        if (cache.hasOwnProperty(key)) return cache[key];
                        cache[key] = promise_ZalgoPromise.try(function() {
                            return method.apply(_this, _arguments);
                        }).finally(function() {
                            delete cache[key];
                        });
                        return cache[key];
                    }
                    memoizedPromiseFunction.reset = function() {
                        cache = {};
                    };
                    return setFunctionName(memoizedPromiseFunction, getFunctionName(method) + "::promiseMemoized");
                }
                function src_util_noop() {}
                function stringifyError(err, level) {
                    void 0 === level && (level = 1);
                    if (level >= 3) return "stringifyError stack overflow";
                    try {
                        if (!err) return "<unknown error: " + ({}).toString.call(err) + ">";
                        if ("string" == typeof err) return err;
                        if (err instanceof Error) {
                            var stack = err && err.stack;
                            var message = err && err.message;
                            if (stack && message) return -1 !== stack.indexOf(message) ? stack : message + "\n" + stack;
                            if (stack) return stack;
                            if (message) return message;
                        }
                        return err && err.toString && "function" == typeof err.toString ? err.toString() : ({}).toString.call(err);
                    } catch (newErr) {
                        return "Error while stringifying error: " + stringifyError(newErr, level + 1);
                    }
                }
                function stringify(item) {
                    return "string" == typeof item ? item : item && item.toString && "function" == typeof item.toString ? item.toString() : ({}).toString.call(item);
                }
                memoize(function(obj) {
                    if (Object.values) return Object.values(obj);
                    var result = [];
                    for(var key in obj)obj.hasOwnProperty(key) && result.push(obj[key]);
                    return result;
                });
                function util_isRegex(item) {
                    return "[object RegExp]" === ({}).toString.call(item);
                }
                function util_getOrSet(obj, key, getter) {
                    if (obj.hasOwnProperty(key)) return obj[key];
                    var val = getter();
                    obj[key] = val;
                    return val;
                }
                function getBody() {
                    var body = document.body;
                    if (!body) throw new Error("Body element not found");
                    return body;
                }
                function isDocumentReady() {
                    return Boolean(document.body) && "complete" === document.readyState;
                }
                function isDocumentInteractive() {
                    return Boolean(document.body) && "interactive" === document.readyState;
                }
                memoize(function() {
                    return new promise_ZalgoPromise(function(resolve) {
                        if (isDocumentReady() || isDocumentInteractive()) return resolve();
                        var interval = setInterval(function() {
                            if (isDocumentReady() || isDocumentInteractive()) {
                                clearInterval(interval);
                                return resolve();
                            }
                        }, 10);
                    });
                });
                var currentScript = "undefined" != typeof document ? document.currentScript : null;
                var getCurrentScript = memoize(function() {
                    if (currentScript) return currentScript;
                    if (currentScript = function() {
                        try {
                            var stack = function() {
                                try {
                                    throw new Error("_");
                                } catch (err) {
                                    return err.stack || "";
                                }
                            }();
                            var stackDetails = /.*at [^(]*\((.*):(.+):(.+)\)$/gi.exec(stack);
                            var scriptLocation = stackDetails && stackDetails[1];
                            if (!scriptLocation) return;
                            for(var _i22 = 0, _Array$prototype$slic2 = [].slice.call(document.getElementsByTagName("script")).reverse(); _i22 < _Array$prototype$slic2.length; _i22++){
                                var script = _Array$prototype$slic2[_i22];
                                if (script.src && script.src === scriptLocation) return script;
                            }
                        } catch (err) {}
                    }()) return currentScript;
                    throw new Error("Can not determine current script");
                });
                var currentUID = uniqueID();
                memoize(function() {
                    var script;
                    try {
                        script = getCurrentScript();
                    } catch (err) {
                        return currentUID;
                    }
                    var uid = script.getAttribute("data-uid");
                    if (uid && "string" == typeof uid) return uid;
                    if ((uid = script.getAttribute("data-uid-auto")) && "string" == typeof uid) return uid;
                    if (script.src) {
                        var hashedString = function(str) {
                            var hash = "";
                            for(var i = 0; i < str.length; i++){
                                var total = str[i].charCodeAt(0) * i;
                                str[i + 1] && (total += str[i + 1].charCodeAt(0) * (i - 1));
                                hash += String.fromCharCode(97 + Math.abs(total) % 26);
                            }
                            return hash;
                        }(JSON.stringify({
                            src: script.src,
                            dataset: script.dataset
                        }));
                        uid = "uid_" + hashedString.slice(hashedString.length - 30);
                    } else uid = uniqueID();
                    script.setAttribute("data-uid-auto", uid);
                    return uid;
                });
                function global_getGlobal(win) {
                    void 0 === win && (win = window);
                    var globalKey = "__post_robot_10_0_46__";
                    return win !== window ? win[globalKey] : win[globalKey] = win[globalKey] || {};
                }
                var getObj = function() {
                    return {};
                };
                function globalStore(key, defStore) {
                    void 0 === key && (key = "store");
                    void 0 === defStore && (defStore = getObj);
                    return util_getOrSet(global_getGlobal(), key, function() {
                        var store = defStore();
                        return {
                            has: function(storeKey) {
                                return store.hasOwnProperty(storeKey);
                            },
                            get: function(storeKey, defVal) {
                                return store.hasOwnProperty(storeKey) ? store[storeKey] : defVal;
                            },
                            set: function(storeKey, val) {
                                store[storeKey] = val;
                                return val;
                            },
                            del: function(storeKey) {
                                delete store[storeKey];
                            },
                            getOrSet: function(storeKey, getter) {
                                return util_getOrSet(store, storeKey, getter);
                            },
                            reset: function() {
                                store = defStore();
                            },
                            keys: function() {
                                return Object.keys(store);
                            }
                        };
                    });
                }
                var WildCard = function() {};
                function getWildcard() {
                    var global1 = global_getGlobal();
                    global1.WINDOW_WILDCARD = global1.WINDOW_WILDCARD || new WildCard;
                    return global1.WINDOW_WILDCARD;
                }
                function windowStore(key, defStore) {
                    void 0 === key && (key = "store");
                    void 0 === defStore && (defStore = getObj);
                    return globalStore("windowStore").getOrSet(key, function() {
                        var winStore = new weakmap_CrossDomainSafeWeakMap;
                        var getStore = function(win) {
                            return winStore.getOrSet(win, defStore);
                        };
                        return {
                            has: function(win) {
                                return getStore(win).hasOwnProperty(key);
                            },
                            get: function(win, defVal) {
                                var store = getStore(win);
                                return store.hasOwnProperty(key) ? store[key] : defVal;
                            },
                            set: function(win, val) {
                                getStore(win)[key] = val;
                                return val;
                            },
                            del: function(win) {
                                delete getStore(win)[key];
                            },
                            getOrSet: function(win, getter) {
                                return util_getOrSet(getStore(win), key, getter);
                            }
                        };
                    });
                }
                function getInstanceID() {
                    return globalStore("instance").getOrSet("instanceID", uniqueID);
                }
                function resolveHelloPromise(win, _ref) {
                    var domain = _ref.domain;
                    var helloPromises = windowStore("helloPromises");
                    var existingPromise = helloPromises.get(win);
                    existingPromise && existingPromise.resolve({
                        domain: domain
                    });
                    var newPromise = promise_ZalgoPromise.resolve({
                        domain: domain
                    });
                    helloPromises.set(win, newPromise);
                    return newPromise;
                }
                function sayHello(win, _ref4) {
                    return (0, _ref4.send)(win, "postrobot_hello", {
                        instanceID: getInstanceID()
                    }, {
                        domain: "*",
                        timeout: -1
                    }).then(function(_ref5) {
                        var origin = _ref5.origin, instanceID = _ref5.data.instanceID;
                        resolveHelloPromise(win, {
                            domain: origin
                        });
                        return {
                            win: win,
                            domain: origin,
                            instanceID: instanceID
                        };
                    });
                }
                function getWindowInstanceID(win, _ref6) {
                    var send = _ref6.send;
                    return windowStore("windowInstanceIDPromises").getOrSet(win, function() {
                        return sayHello(win, {
                            send: send
                        }).then(function(_ref7) {
                            return _ref7.instanceID;
                        });
                    });
                }
                function markWindowKnown(win) {
                    windowStore("knownWindows").set(win, !0);
                }
                function isSerializedType(item) {
                    return "object" == typeof item && null !== item && "string" == typeof item.__type__;
                }
                function determineType(val) {
                    return void 0 === val ? "undefined" : null === val ? "null" : Array.isArray(val) ? "array" : "function" == typeof val ? "function" : "object" == typeof val ? val instanceof Error ? "error" : "function" == typeof val.then ? "promise" : "[object RegExp]" === ({}).toString.call(val) ? "regex" : "[object Date]" === ({}).toString.call(val) ? "date" : "object" : "string" == typeof val ? "string" : "number" == typeof val ? "number" : "boolean" == typeof val ? "boolean" : void 0;
                }
                function serializeType(type, val) {
                    return {
                        __type__: type,
                        __val__: val
                    };
                }
                var _SERIALIZER;
                var SERIALIZER = ((_SERIALIZER = {}).function = function() {}, _SERIALIZER.error = function(_ref) {
                    return serializeType("error", {
                        message: _ref.message,
                        stack: _ref.stack,
                        code: _ref.code,
                        data: _ref.data
                    });
                }, _SERIALIZER.promise = function() {}, _SERIALIZER.regex = function(val) {
                    return serializeType("regex", val.source);
                }, _SERIALIZER.date = function(val) {
                    return serializeType("date", val.toJSON());
                }, _SERIALIZER.array = function(val) {
                    return val;
                }, _SERIALIZER.object = function(val) {
                    return val;
                }, _SERIALIZER.string = function(val) {
                    return val;
                }, _SERIALIZER.number = function(val) {
                    return val;
                }, _SERIALIZER.boolean = function(val) {
                    return val;
                }, _SERIALIZER.null = function(val) {
                    return val;
                }, _SERIALIZER[void 0] = function(val) {
                    return serializeType("undefined", val);
                }, _SERIALIZER);
                var defaultSerializers = {};
                var _DESERIALIZER;
                var DESERIALIZER = ((_DESERIALIZER = {}).function = function() {
                    throw new Error("Function serialization is not implemented; nothing to deserialize");
                }, _DESERIALIZER.error = function(_ref2) {
                    var stack = _ref2.stack, code = _ref2.code, data = _ref2.data;
                    var error = new Error(_ref2.message);
                    error.code = code;
                    data && (error.data = data);
                    error.stack = stack + "\n\n" + error.stack;
                    return error;
                }, _DESERIALIZER.promise = function() {
                    throw new Error("Promise serialization is not implemented; nothing to deserialize");
                }, _DESERIALIZER.regex = function(val) {
                    return new RegExp(val);
                }, _DESERIALIZER.date = function(val) {
                    return new Date(val);
                }, _DESERIALIZER.array = function(val) {
                    return val;
                }, _DESERIALIZER.object = function(val) {
                    return val;
                }, _DESERIALIZER.string = function(val) {
                    return val;
                }, _DESERIALIZER.number = function(val) {
                    return val;
                }, _DESERIALIZER.boolean = function(val) {
                    return val;
                }, _DESERIALIZER.null = function(val) {
                    return val;
                }, _DESERIALIZER[void 0] = function() {}, _DESERIALIZER);
                var defaultDeserializers = {};
                new promise_ZalgoPromise(function(resolve) {
                    if (window.document && window.document.body) return resolve(window.document.body);
                    var interval = setInterval(function() {
                        if (window.document && window.document.body) {
                            clearInterval(interval);
                            return resolve(window.document.body);
                        }
                    }, 10);
                });
                function cleanupProxyWindows() {
                    var idToProxyWindow = globalStore("idToProxyWindow");
                    for(var _i2 = 0, _idToProxyWindow$keys2 = idToProxyWindow.keys(); _i2 < _idToProxyWindow$keys2.length; _i2++){
                        var id = _idToProxyWindow$keys2[_i2];
                        idToProxyWindow.get(id).shouldClean() && idToProxyWindow.del(id);
                    }
                }
                function getSerializedWindow(winPromise, _ref) {
                    var send = _ref.send, _ref$id = _ref.id, id = void 0 === _ref$id ? uniqueID() : _ref$id;
                    var windowNamePromise = winPromise.then(function(win) {
                        if (isSameDomain(win)) return assertSameDomain(win).name;
                    });
                    var windowTypePromise = winPromise.then(function(window1) {
                        if (isWindowClosed(window1)) throw new Error("Window is closed, can not determine type");
                        return getOpener(window1) ? "popup" : "iframe";
                    });
                    windowNamePromise.catch(src_util_noop);
                    windowTypePromise.catch(src_util_noop);
                    var getName = function() {
                        return winPromise.then(function(win) {
                            if (!isWindowClosed(win)) return isSameDomain(win) ? assertSameDomain(win).name : windowNamePromise;
                        });
                    };
                    return {
                        id: id,
                        getType: function() {
                            return windowTypePromise;
                        },
                        getInstanceID: memoizePromise(function() {
                            return winPromise.then(function(win) {
                                return getWindowInstanceID(win, {
                                    send: send
                                });
                            });
                        }),
                        close: function() {
                            return winPromise.then(closeWindow);
                        },
                        getName: getName,
                        focus: function() {
                            return winPromise.then(function(win) {
                                win.focus();
                            });
                        },
                        isClosed: function() {
                            return winPromise.then(function(win) {
                                return isWindowClosed(win);
                            });
                        },
                        setLocation: function(href, opts) {
                            void 0 === opts && (opts = {});
                            return winPromise.then(function(win) {
                                var domain = window.location.protocol + "//" + window.location.host;
                                var _opts$method = opts.method, method = void 0 === _opts$method ? "get" : _opts$method, body = opts.body;
                                if (0 === href.indexOf("/")) href = "" + domain + href;
                                else if (!href.match(/^https?:\/\//) && 0 !== href.indexOf(domain)) throw new Error("Expected url to be http or https url, or absolute path, got " + JSON.stringify(href));
                                if ("post" === method) return getName().then(function(name) {
                                    if (!name) throw new Error("Can not post to window without target name");
                                    !function(_ref3) {
                                        var url = _ref3.url, target = _ref3.target, body = _ref3.body, _ref3$method = _ref3.method, method = void 0 === _ref3$method ? "post" : _ref3$method;
                                        var form = document.createElement("form");
                                        form.setAttribute("target", target);
                                        form.setAttribute("method", method);
                                        form.setAttribute("action", url);
                                        form.style.display = "none";
                                        if (body) for(var _i24 = 0, _Object$keys4 = Object.keys(body); _i24 < _Object$keys4.length; _i24++){
                                            var _body$key;
                                            var key = _Object$keys4[_i24];
                                            var input = document.createElement("input");
                                            input.setAttribute("name", key);
                                            input.setAttribute("value", null == (_body$key = body[key]) ? void 0 : _body$key.toString());
                                            form.appendChild(input);
                                        }
                                        getBody().appendChild(form);
                                        form.submit();
                                        getBody().removeChild(form);
                                    }({
                                        url: href,
                                        target: name,
                                        method: method,
                                        body: body
                                    });
                                });
                                if ("get" !== method) throw new Error("Unsupported method: " + method);
                                if (isSameDomain(win)) try {
                                    if (win.location && "function" == typeof win.location.replace) {
                                        win.location.replace(href);
                                        return;
                                    }
                                } catch (err) {}
                                win.location = href;
                            });
                        },
                        setName: function(name) {
                            return winPromise.then(function(win) {
                                var sameDomain = isSameDomain(win);
                                var frame = getFrameForWindow(win);
                                if (!sameDomain) throw new Error("Can not set name for cross-domain window: " + name);
                                assertSameDomain(win).name = name;
                                frame && frame.setAttribute("name", name);
                                windowNamePromise = promise_ZalgoPromise.resolve(name);
                            });
                        }
                    };
                }
                var window_ProxyWindow = function() {
                    function ProxyWindow(_ref2) {
                        var send = _ref2.send, win = _ref2.win, serializedWindow = _ref2.serializedWindow;
                        this.id = void 0;
                        this.isProxyWindow = !0;
                        this.serializedWindow = void 0;
                        this.actualWindow = void 0;
                        this.actualWindowPromise = void 0;
                        this.send = void 0;
                        this.name = void 0;
                        this.actualWindowPromise = new promise_ZalgoPromise;
                        this.serializedWindow = serializedWindow || getSerializedWindow(this.actualWindowPromise, {
                            send: send
                        });
                        globalStore("idToProxyWindow").set(this.getID(), this);
                        win && this.setWindow(win, {
                            send: send
                        });
                    }
                    var _proto = ProxyWindow.prototype;
                    _proto.getID = function() {
                        return this.serializedWindow.id;
                    };
                    _proto.getType = function() {
                        return this.serializedWindow.getType();
                    };
                    _proto.isPopup = function() {
                        return this.getType().then(function(type) {
                            return "popup" === type;
                        });
                    };
                    _proto.setLocation = function(href, opts) {
                        var _this = this;
                        return this.serializedWindow.setLocation(href, opts).then(function() {
                            return _this;
                        });
                    };
                    _proto.getName = function() {
                        return this.serializedWindow.getName();
                    };
                    _proto.setName = function(name) {
                        var _this2 = this;
                        return this.serializedWindow.setName(name).then(function() {
                            return _this2;
                        });
                    };
                    _proto.close = function() {
                        var _this3 = this;
                        return this.serializedWindow.close().then(function() {
                            return _this3;
                        });
                    };
                    _proto.focus = function() {
                        var _this4 = this;
                        var isPopupPromise = this.isPopup();
                        var getNamePromise = this.getName();
                        var reopenPromise = promise_ZalgoPromise.hash({
                            isPopup: isPopupPromise,
                            name: getNamePromise
                        }).then(function(_ref3) {
                            var name = _ref3.name;
                            _ref3.isPopup && name && window.open("", name, "noopener");
                        });
                        var focusPromise = this.serializedWindow.focus();
                        return promise_ZalgoPromise.all([
                            reopenPromise,
                            focusPromise
                        ]).then(function() {
                            return _this4;
                        });
                    };
                    _proto.isClosed = function() {
                        return this.serializedWindow.isClosed();
                    };
                    _proto.getWindow = function() {
                        return this.actualWindow;
                    };
                    _proto.setWindow = function(win, _ref4) {
                        var send = _ref4.send;
                        this.actualWindow = win;
                        this.actualWindowPromise.resolve(this.actualWindow);
                        this.serializedWindow = getSerializedWindow(this.actualWindowPromise, {
                            send: send,
                            id: this.getID()
                        });
                        windowStore("winToProxyWindow").set(win, this);
                    };
                    _proto.awaitWindow = function() {
                        return this.actualWindowPromise;
                    };
                    _proto.matchWindow = function(win, _ref5) {
                        var _this5 = this;
                        var send = _ref5.send;
                        return promise_ZalgoPromise.try(function() {
                            return _this5.actualWindow ? win === _this5.actualWindow : promise_ZalgoPromise.hash({
                                proxyInstanceID: _this5.getInstanceID(),
                                knownWindowInstanceID: getWindowInstanceID(win, {
                                    send: send
                                })
                            }).then(function(_ref6) {
                                var match = _ref6.proxyInstanceID === _ref6.knownWindowInstanceID;
                                match && _this5.setWindow(win, {
                                    send: send
                                });
                                return match;
                            });
                        });
                    };
                    _proto.unwrap = function() {
                        return this.actualWindow || this;
                    };
                    _proto.getInstanceID = function() {
                        return this.serializedWindow.getInstanceID();
                    };
                    _proto.shouldClean = function() {
                        return Boolean(this.actualWindow && isWindowClosed(this.actualWindow));
                    };
                    _proto.serialize = function() {
                        return this.serializedWindow;
                    };
                    ProxyWindow.unwrap = function(win) {
                        return ProxyWindow.isProxyWindow(win) ? win.unwrap() : win;
                    };
                    ProxyWindow.serialize = function(win, _ref7) {
                        var send = _ref7.send;
                        cleanupProxyWindows();
                        return ProxyWindow.toProxyWindow(win, {
                            send: send
                        }).serialize();
                    };
                    ProxyWindow.deserialize = function(serializedWindow, _ref8) {
                        var send = _ref8.send;
                        cleanupProxyWindows();
                        return globalStore("idToProxyWindow").get(serializedWindow.id) || new ProxyWindow({
                            serializedWindow: serializedWindow,
                            send: send
                        });
                    };
                    ProxyWindow.isProxyWindow = function(obj) {
                        return Boolean(obj && !isWindow(obj) && obj.isProxyWindow);
                    };
                    ProxyWindow.toProxyWindow = function(win, _ref9) {
                        var send = _ref9.send;
                        cleanupProxyWindows();
                        if (ProxyWindow.isProxyWindow(win)) return win;
                        var actualWindow = win;
                        return windowStore("winToProxyWindow").get(actualWindow) || new ProxyWindow({
                            win: actualWindow,
                            send: send
                        });
                    };
                    return ProxyWindow;
                }();
                function addMethod(id, val, name, source, domain) {
                    var methodStore = windowStore("methodStore");
                    var proxyWindowMethods = globalStore("proxyWindowMethods");
                    if (window_ProxyWindow.isProxyWindow(source)) proxyWindowMethods.set(id, {
                        val: val,
                        name: name,
                        domain: domain,
                        source: source
                    });
                    else {
                        proxyWindowMethods.del(id);
                        methodStore.getOrSet(source, function() {
                            return {};
                        })[id] = {
                            domain: domain,
                            name: name,
                            val: val,
                            source: source
                        };
                    }
                }
                function lookupMethod(source, id) {
                    var methodStore = windowStore("methodStore");
                    var proxyWindowMethods = globalStore("proxyWindowMethods");
                    return methodStore.getOrSet(source, function() {
                        return {};
                    })[id] || proxyWindowMethods.get(id);
                }
                function function_serializeFunction(destination, domain, val, key, _ref3) {
                    on = (_ref = {
                        on: _ref3.on,
                        send: _ref3.send
                    }).on, send = _ref.send, globalStore("builtinListeners").getOrSet("functionCalls", function() {
                        return on("postrobot_method", {
                            domain: "*"
                        }, function(_ref2) {
                            var source = _ref2.source, origin = _ref2.origin, data = _ref2.data;
                            var id = data.id, name = data.name;
                            var meth = lookupMethod(source, id);
                            if (!meth) throw new Error("Could not find method '" + name + "' with id: " + data.id + " in " + getDomain(window));
                            var methodSource = meth.source, domain = meth.domain, val = meth.val;
                            return promise_ZalgoPromise.try(function() {
                                if (!matchDomain(domain, origin)) throw new Error("Method '" + data.name + "' domain " + JSON.stringify(util_isRegex(meth.domain) ? meth.domain.source : meth.domain) + " does not match origin " + origin + " in " + getDomain(window));
                                if (window_ProxyWindow.isProxyWindow(methodSource)) return methodSource.matchWindow(source, {
                                    send: send
                                }).then(function(match) {
                                    if (!match) throw new Error("Method call '" + data.name + "' failed - proxy window does not match source in " + getDomain(window));
                                });
                            }).then(function() {
                                return val.apply({
                                    source: source,
                                    origin: origin
                                }, data.args);
                            }, function(err) {
                                return promise_ZalgoPromise.try(function() {
                                    if (val.onError) return val.onError(err);
                                }).then(function() {
                                    err.stack && (err.stack = "Remote call to " + name + "(" + function(args) {
                                        void 0 === args && (args = []);
                                        return (item = args, [].slice.call(item)).map(function(arg) {
                                            return "string" == typeof arg ? "'" + arg + "'" : void 0 === arg ? "undefined" : null === arg ? "null" : "boolean" == typeof arg ? arg.toString() : Array.isArray(arg) ? "[ ... ]" : "object" == typeof arg ? "{ ... }" : "function" == typeof arg ? "() => { ... }" : "<" + typeof arg + ">";
                                        }).join(", ");
                                        "TURBOPACK unreachable";
                                        var item;
                                    }(data.args) + ") failed\n\n" + err.stack);
                                    throw err;
                                });
                            }).then(function(result) {
                                return {
                                    result: result,
                                    id: id,
                                    name: name
                                };
                            });
                        });
                    });
                    var _ref, on, send;
                    var id = val.__id__ || uniqueID();
                    destination = window_ProxyWindow.unwrap(destination);
                    var name = val.__name__ || val.name || key;
                    "string" == typeof name && "function" == typeof name.indexOf && 0 === name.indexOf("anonymous::") && (name = name.replace("anonymous::", key + "::"));
                    if (window_ProxyWindow.isProxyWindow(destination)) {
                        addMethod(id, val, name, destination, domain);
                        destination.awaitWindow().then(function(win) {
                            addMethod(id, val, name, win, domain);
                        });
                    } else addMethod(id, val, name, destination, domain);
                    return serializeType("cross_domain_function", {
                        id: id,
                        name: name
                    });
                }
                function serializeMessage(destination, domain, obj, _ref) {
                    var _serialize;
                    var on = _ref.on, send = _ref.send;
                    return function(obj, serializers) {
                        void 0 === serializers && (serializers = defaultSerializers);
                        var result = JSON.stringify(obj, function(key) {
                            var val = this[key];
                            if (isSerializedType(this)) return val;
                            var type = determineType(val);
                            if (!type) return val;
                            var serializer = serializers[type] || SERIALIZER[type];
                            return serializer ? serializer(val, key) : val;
                        });
                        return void 0 === result ? "undefined" : result;
                    }(obj, ((_serialize = {}).promise = function(val, key) {
                        return function(destination, domain, val, key, _ref) {
                            return serializeType("cross_domain_zalgo_promise", {
                                then: function_serializeFunction(destination, domain, function(resolve, reject) {
                                    return val.then(resolve, reject);
                                }, key, {
                                    on: _ref.on,
                                    send: _ref.send
                                })
                            });
                        }(destination, domain, val, key, {
                            on: on,
                            send: send
                        });
                    }, _serialize.function = function(val, key) {
                        return function_serializeFunction(destination, domain, val, key, {
                            on: on,
                            send: send
                        });
                    }, _serialize.object = function(val) {
                        return isWindow(val) || window_ProxyWindow.isProxyWindow(val) ? serializeType("cross_domain_window", window_ProxyWindow.serialize(val, {
                            send: send
                        })) : val;
                    }, _serialize));
                }
                function deserializeMessage(source, origin, message, _ref2) {
                    var _deserialize;
                    var send = _ref2.send;
                    return function(str, deserializers) {
                        void 0 === deserializers && (deserializers = defaultDeserializers);
                        if ("undefined" !== str) return JSON.parse(str, function(key, val) {
                            if (isSerializedType(this)) return val;
                            var type;
                            var value;
                            if (isSerializedType(val)) {
                                type = val.__type__;
                                value = val.__val__;
                            } else {
                                type = determineType(val);
                                value = val;
                            }
                            if (!type) return value;
                            var deserializer = deserializers[type] || DESERIALIZER[type];
                            return deserializer ? deserializer(value, key) : value;
                        });
                    }(message, ((_deserialize = {}).cross_domain_zalgo_promise = function(serializedPromise) {
                        return function(source, origin, _ref2) {
                            return new promise_ZalgoPromise(_ref2.then);
                        }(0, 0, serializedPromise);
                    }, _deserialize.cross_domain_function = function(serializedFunction) {
                        return function(source, origin, _ref4, _ref5) {
                            var id = _ref4.id, name = _ref4.name;
                            var send = _ref5.send;
                            var getDeserializedFunction = function(opts) {
                                void 0 === opts && (opts = {});
                                function crossDomainFunctionWrapper() {
                                    var _arguments = arguments;
                                    return window_ProxyWindow.toProxyWindow(source, {
                                        send: send
                                    }).awaitWindow().then(function(win) {
                                        var meth = lookupMethod(win, id);
                                        if (meth && meth.val !== crossDomainFunctionWrapper) return meth.val.apply({
                                            source: window,
                                            origin: getDomain()
                                        }, _arguments);
                                        var _args = [].slice.call(_arguments);
                                        return opts.fireAndForget ? send(win, "postrobot_method", {
                                            id: id,
                                            name: name,
                                            args: _args
                                        }, {
                                            domain: origin,
                                            fireAndForget: !0
                                        }) : send(win, "postrobot_method", {
                                            id: id,
                                            name: name,
                                            args: _args
                                        }, {
                                            domain: origin,
                                            fireAndForget: !1
                                        }).then(function(res) {
                                            return res.data.result;
                                        });
                                    }).catch(function(err) {
                                        throw err;
                                    });
                                }
                                crossDomainFunctionWrapper.__name__ = name;
                                crossDomainFunctionWrapper.__origin__ = origin;
                                crossDomainFunctionWrapper.__source__ = source;
                                crossDomainFunctionWrapper.__id__ = id;
                                crossDomainFunctionWrapper.origin = origin;
                                return crossDomainFunctionWrapper;
                            };
                            var crossDomainFunctionWrapper = getDeserializedFunction();
                            crossDomainFunctionWrapper.fireAndForget = getDeserializedFunction({
                                fireAndForget: !0
                            });
                            return crossDomainFunctionWrapper;
                        }(source, origin, serializedFunction, {
                            send: send
                        });
                    }, _deserialize.cross_domain_window = function(serializedWindow) {
                        return window_ProxyWindow.deserialize(serializedWindow, {
                            send: send
                        });
                    }, _deserialize));
                }
                var SEND_MESSAGE_STRATEGIES = {};
                SEND_MESSAGE_STRATEGIES.postrobot_post_message = function(win, serializedMessage, domain) {
                    0 === domain.indexOf("file:") && (domain = "*");
                    win.postMessage(serializedMessage, domain);
                };
                function send_sendMessage(win, domain, message, _ref2) {
                    var on = _ref2.on, send = _ref2.send;
                    return promise_ZalgoPromise.try(function() {
                        var domainBuffer = windowStore().getOrSet(win, function() {
                            return {};
                        });
                        domainBuffer.buffer = domainBuffer.buffer || [];
                        domainBuffer.buffer.push(message);
                        domainBuffer.flush = domainBuffer.flush || promise_ZalgoPromise.flush().then(function() {
                            if (isWindowClosed(win)) throw new Error("Window is closed");
                            var serializedMessage = serializeMessage(win, domain, ((_ref = {}).__post_robot_10_0_46__ = domainBuffer.buffer || [], _ref), {
                                on: on,
                                send: send
                            });
                            var _ref;
                            delete domainBuffer.buffer;
                            var strategies = Object.keys(SEND_MESSAGE_STRATEGIES);
                            var errors = [];
                            for(var _i2 = 0; _i2 < strategies.length; _i2++){
                                var strategyName = strategies[_i2];
                                try {
                                    SEND_MESSAGE_STRATEGIES[strategyName](win, serializedMessage, domain);
                                } catch (err) {
                                    errors.push(err);
                                }
                            }
                            if (errors.length === strategies.length) throw new Error("All post-robot messaging strategies failed:\n\n" + errors.map(function(err, i) {
                                return i + ". " + stringifyError(err);
                            }).join("\n\n"));
                        });
                        return domainBuffer.flush.then(function() {
                            delete domainBuffer.flush;
                        });
                    }).then(src_util_noop);
                }
                function getResponseListener(hash) {
                    return globalStore("responseListeners").get(hash);
                }
                function deleteResponseListener(hash) {
                    globalStore("responseListeners").del(hash);
                }
                function isResponseListenerErrored(hash) {
                    return globalStore("erroredResponseListeners").has(hash);
                }
                function getRequestListener(_ref) {
                    var name = _ref.name, win = _ref.win, domain = _ref.domain;
                    var requestListeners = windowStore("requestListeners");
                    "*" === win && (win = null);
                    "*" === domain && (domain = null);
                    if (!name) throw new Error("Name required to get request listener");
                    for(var _i4 = 0, _ref3 = [
                        win,
                        getWildcard()
                    ]; _i4 < _ref3.length; _i4++){
                        var winQualifier = _ref3[_i4];
                        if (winQualifier) {
                            var nameListeners = requestListeners.get(winQualifier);
                            if (nameListeners) {
                                var domainListeners = nameListeners[name];
                                if (domainListeners) {
                                    if (domain && "string" == typeof domain) {
                                        if (domainListeners[domain]) return domainListeners[domain];
                                        if (domainListeners.__domain_regex__) for(var _i6 = 0, _domainListeners$__DO2 = domainListeners.__domain_regex__; _i6 < _domainListeners$__DO2.length; _i6++){
                                            var _domainListeners$__DO3 = _domainListeners$__DO2[_i6], listener = _domainListeners$__DO3.listener;
                                            if (matchDomain(_domainListeners$__DO3.regex, domain)) return listener;
                                        }
                                    }
                                    if (domainListeners["*"]) return domainListeners["*"];
                                }
                            }
                        }
                    }
                }
                function handleRequest(source, origin, message, _ref) {
                    var on = _ref.on, send = _ref.send;
                    var options = getRequestListener({
                        name: message.name,
                        win: source,
                        domain: origin
                    });
                    var logName = "postrobot_method" === message.name && message.data && "string" == typeof message.data.name ? message.data.name + "()" : message.name;
                    function sendResponse(ack, data, error) {
                        return promise_ZalgoPromise.flush().then(function() {
                            if (!message.fireAndForget && !isWindowClosed(source)) try {
                                return send_sendMessage(source, origin, {
                                    id: uniqueID(),
                                    origin: getDomain(window),
                                    type: "postrobot_message_response",
                                    hash: message.hash,
                                    name: message.name,
                                    ack: ack,
                                    data: data,
                                    error: error
                                }, {
                                    on: on,
                                    send: send
                                });
                            } catch (err) {
                                throw new Error("Send response message failed for " + logName + " in " + getDomain() + "\n\n" + stringifyError(err));
                            }
                        });
                    }
                    return promise_ZalgoPromise.all([
                        promise_ZalgoPromise.flush().then(function() {
                            if (!message.fireAndForget && !isWindowClosed(source)) try {
                                return send_sendMessage(source, origin, {
                                    id: uniqueID(),
                                    origin: getDomain(window),
                                    type: "postrobot_message_ack",
                                    hash: message.hash,
                                    name: message.name
                                }, {
                                    on: on,
                                    send: send
                                });
                            } catch (err) {
                                throw new Error("Send ack message failed for " + logName + " in " + getDomain() + "\n\n" + stringifyError(err));
                            }
                        }),
                        promise_ZalgoPromise.try(function() {
                            if (!options) throw new Error("No handler found for post message: " + message.name + " from " + origin + " in " + window.location.protocol + "//" + window.location.host + window.location.pathname);
                            return options.handler({
                                source: source,
                                origin: origin,
                                data: message.data
                            });
                        }).then(function(data) {
                            return sendResponse("success", data);
                        }, function(error) {
                            return sendResponse("error", null, error);
                        })
                    ]).then(src_util_noop).catch(function(err) {
                        if (options && options.handleError) return options.handleError(err);
                        throw err;
                    });
                }
                function handleAck(source, origin, message) {
                    if (!isResponseListenerErrored(message.hash)) {
                        var options = getResponseListener(message.hash);
                        if (!options) throw new Error("No handler found for post message ack for message: " + message.name + " from " + origin + " in " + window.location.protocol + "//" + window.location.host + window.location.pathname);
                        try {
                            if (!matchDomain(options.domain, origin)) throw new Error("Ack origin " + origin + " does not match domain " + options.domain.toString());
                            if (source !== options.win) throw new Error("Ack source does not match registered window");
                        } catch (err) {
                            options.promise.reject(err);
                        }
                        options.ack = !0;
                    }
                }
                function handleResponse(source, origin, message) {
                    if (!isResponseListenerErrored(message.hash)) {
                        var options = getResponseListener(message.hash);
                        if (!options) throw new Error("No handler found for post message response for message: " + message.name + " from " + origin + " in " + window.location.protocol + "//" + window.location.host + window.location.pathname);
                        if (!matchDomain(options.domain, origin)) throw new Error("Response origin " + origin + " does not match domain " + (pattern = options.domain, Array.isArray(pattern) ? "(" + pattern.join(" | ") + ")" : isRegex(pattern) ? "RegExp(" + pattern.toString() + ")" : pattern.toString()));
                        var pattern;
                        if (source !== options.win) throw new Error("Response source does not match registered window");
                        deleteResponseListener(message.hash);
                        "error" === message.ack ? options.promise.reject(message.error) : "success" === message.ack && options.promise.resolve({
                            source: source,
                            origin: origin,
                            data: message.data
                        });
                    }
                }
                function receive_receiveMessage(event, _ref2) {
                    var on = _ref2.on, send = _ref2.send;
                    var receivedMessages = globalStore("receivedMessages");
                    try {
                        if (!window || window.closed || !event.source) return;
                    } catch (err) {
                        return;
                    }
                    var source = event.source, origin = event.origin;
                    var messages = function(message, source, origin, _ref) {
                        var on = _ref.on, send = _ref.send;
                        var parsedMessage;
                        try {
                            parsedMessage = deserializeMessage(source, origin, message, {
                                on: on,
                                send: send
                            });
                        } catch (err) {
                            return;
                        }
                        if (parsedMessage && "object" == typeof parsedMessage && null !== parsedMessage) {
                            var parseMessages = parsedMessage.__post_robot_10_0_46__;
                            if (Array.isArray(parseMessages)) return parseMessages;
                        }
                    }(event.data, source, origin, {
                        on: on,
                        send: send
                    });
                    if (messages) {
                        markWindowKnown(source);
                        for(var _i2 = 0; _i2 < messages.length; _i2++){
                            var message = messages[_i2];
                            if (receivedMessages.has(message.id)) return;
                            receivedMessages.set(message.id, !0);
                            if (isWindowClosed(source) && !message.fireAndForget) return;
                            0 === message.origin.indexOf("file:") && (origin = "file://");
                            try {
                                "postrobot_message_request" === message.type ? handleRequest(source, origin, message, {
                                    on: on,
                                    send: send
                                }) : "postrobot_message_response" === message.type ? handleResponse(source, origin, message) : "postrobot_message_ack" === message.type && handleAck(source, origin, message);
                            } catch (err) {
                                setTimeout(function() {
                                    throw err;
                                }, 0);
                            }
                        }
                    }
                }
                function on_on(name, options, handler) {
                    if (!name) throw new Error("Expected name");
                    if ("function" == typeof (options = options || {})) {
                        handler = options;
                        options = {};
                    }
                    if (!handler) throw new Error("Expected handler");
                    var requestListener = function addRequestListener(_ref4, listener) {
                        var name = _ref4.name, winCandidate = _ref4.win, domain = _ref4.domain;
                        var requestListeners = windowStore("requestListeners");
                        if (!name || "string" != typeof name) throw new Error("Name required to add request listener");
                        if (winCandidate && "*" !== winCandidate && window_ProxyWindow.isProxyWindow(winCandidate)) {
                            var requestListenerPromise = winCandidate.awaitWindow().then(function(actualWin) {
                                return addRequestListener({
                                    name: name,
                                    win: actualWin,
                                    domain: domain
                                }, listener);
                            });
                            return {
                                cancel: function() {
                                    requestListenerPromise.then(function(requestListener) {
                                        return requestListener.cancel();
                                    }, src_util_noop);
                                }
                            };
                        }
                        var win = winCandidate;
                        if (Array.isArray(win)) {
                            var listenersCollection = [];
                            for(var _i8 = 0, _win2 = win; _i8 < _win2.length; _i8++)listenersCollection.push(addRequestListener({
                                name: name,
                                domain: domain,
                                win: _win2[_i8]
                            }, listener));
                            return {
                                cancel: function() {
                                    for(var _i10 = 0; _i10 < listenersCollection.length; _i10++)listenersCollection[_i10].cancel();
                                }
                            };
                        }
                        if (Array.isArray(domain)) {
                            var _listenersCollection = [];
                            for(var _i12 = 0, _domain2 = domain; _i12 < _domain2.length; _i12++)_listenersCollection.push(addRequestListener({
                                name: name,
                                win: win,
                                domain: _domain2[_i12]
                            }, listener));
                            return {
                                cancel: function() {
                                    for(var _i14 = 0; _i14 < _listenersCollection.length; _i14++)_listenersCollection[_i14].cancel();
                                }
                            };
                        }
                        var existingListener = getRequestListener({
                            name: name,
                            win: win,
                            domain: domain
                        });
                        win && "*" !== win || (win = getWildcard());
                        var strDomain = (domain = domain || "*").toString();
                        if (existingListener) throw win && domain ? new Error("Request listener already exists for " + name + " on domain " + domain.toString() + " for " + (win === getWildcard() ? "wildcard" : "specified") + " window") : win ? new Error("Request listener already exists for " + name + " for " + (win === getWildcard() ? "wildcard" : "specified") + " window") : domain ? new Error("Request listener already exists for " + name + " on domain " + domain.toString()) : new Error("Request listener already exists for " + name);
                        var winNameListeners = requestListeners.getOrSet(win, function() {
                            return {};
                        });
                        var winNameDomainListeners = util_getOrSet(winNameListeners, name, function() {
                            return {};
                        });
                        var winNameDomainRegexListeners;
                        var winNameDomainRegexListener;
                        util_isRegex(domain) ? (winNameDomainRegexListeners = util_getOrSet(winNameDomainListeners, "__domain_regex__", function() {
                            return [];
                        })).push(winNameDomainRegexListener = {
                            regex: domain,
                            listener: listener
                        }) : winNameDomainListeners[strDomain] = listener;
                        return {
                            cancel: function() {
                                delete winNameDomainListeners[strDomain];
                                if (winNameDomainRegexListener) {
                                    winNameDomainRegexListeners.splice(winNameDomainRegexListeners.indexOf(winNameDomainRegexListener, 1));
                                    winNameDomainRegexListeners.length || delete winNameDomainListeners.__domain_regex__;
                                }
                                Object.keys(winNameDomainListeners).length || delete winNameListeners[name];
                                win && !Object.keys(winNameListeners).length && requestListeners.del(win);
                            }
                        };
                    }({
                        name: name,
                        win: options.window,
                        domain: options.domain || "*"
                    }, {
                        handler: handler || options.handler,
                        handleError: options.errorHandler || function(err) {
                            throw err;
                        }
                    });
                    return {
                        cancel: function() {
                            requestListener.cancel();
                        }
                    };
                }
                function on_once(name, options, handler) {
                    if ("function" == typeof (options = options || {})) {
                        handler = options;
                        options = {};
                    }
                    var promise = new promise_ZalgoPromise;
                    var listener;
                    options.errorHandler = function(err) {
                        listener.cancel();
                        promise.reject(err);
                    };
                    listener = on_on(name, options, function(event) {
                        listener.cancel();
                        promise.resolve(event);
                        if (handler) return handler(event);
                    });
                    promise.cancel = listener.cancel;
                    return promise;
                }
                var send_send = function send(winOrProxyWin, name, data, options) {
                    var domainMatcher = (options = options || {}).domain || "*";
                    var responseTimeout = options.timeout || -1;
                    var childTimeout = options.timeout || 5e3;
                    var fireAndForget = options.fireAndForget || !1;
                    return window_ProxyWindow.toProxyWindow(winOrProxyWin, {
                        send: send
                    }).awaitWindow().then(function(win) {
                        return promise_ZalgoPromise.try(function() {
                            !function(name, win, domain) {
                                if (!name) throw new Error("Expected name");
                                if (domain && "string" != typeof domain && !Array.isArray(domain) && !util_isRegex(domain)) throw new TypeError("Can not send " + name + ". Expected domain " + JSON.stringify(domain) + " to be a string, array, or regex");
                                if (isWindowClosed(win)) throw new Error("Can not send " + name + ". Target window is closed");
                            }(name, win, domainMatcher);
                            if (function(parent, child) {
                                var actualParent = getAncestor(child);
                                if (actualParent) return actualParent === parent;
                                if (child === parent) return !1;
                                if (function(win) {
                                    void 0 === win && (win = window);
                                    try {
                                        if (win.top) return win.top;
                                    } catch (err) {}
                                    if (getParent(win) === win) return win;
                                    try {
                                        if (isAncestorParent(window, win) && window.top) return window.top;
                                    } catch (err) {}
                                    try {
                                        if (isAncestorParent(win, window) && window.top) return window.top;
                                    } catch (err) {}
                                    for(var _i7 = 0, _getAllChildFrames4 = function getAllChildFrames(win) {
                                        var result = [];
                                        for(var _i3 = 0, _getFrames2 = getFrames(win); _i3 < _getFrames2.length; _i3++){
                                            var frame = _getFrames2[_i3];
                                            result.push(frame);
                                            for(var _i5 = 0, _getAllChildFrames2 = getAllChildFrames(frame); _i5 < _getAllChildFrames2.length; _i5++)result.push(_getAllChildFrames2[_i5]);
                                        }
                                        return result;
                                    }(win); _i7 < _getAllChildFrames4.length; _i7++){
                                        var frame = _getAllChildFrames4[_i7];
                                        try {
                                            if (frame.top) return frame.top;
                                        } catch (err) {}
                                        if (getParent(frame) === frame) return frame;
                                    }
                                }(child) === child) return !1;
                                for(var _i15 = 0, _getFrames8 = getFrames(parent); _i15 < _getFrames8.length; _i15++)if (_getFrames8[_i15] === child) return !0;
                                return !1;
                            }(window, win)) return function(win, timeout, name) {
                                void 0 === timeout && (timeout = 5e3);
                                void 0 === name && (name = "Window");
                                var promise = function(win) {
                                    return windowStore("helloPromises").getOrSet(win, function() {
                                        return new promise_ZalgoPromise;
                                    });
                                }(win);
                                -1 !== timeout && (promise = promise.timeout(timeout, new Error(name + " did not load after " + timeout + "ms")));
                                return promise;
                            }(win, childTimeout);
                        }).then(function(_temp) {
                            return function(win, targetDomain, actualDomain, _ref) {
                                var send = _ref.send;
                                return promise_ZalgoPromise.try(function() {
                                    return "string" == typeof targetDomain ? targetDomain : promise_ZalgoPromise.try(function() {
                                        return actualDomain || sayHello(win, {
                                            send: send
                                        }).then(function(_ref2) {
                                            return _ref2.domain;
                                        });
                                    }).then(function(normalizedDomain) {
                                        if (!matchDomain(targetDomain, targetDomain)) throw new Error("Domain " + stringify(targetDomain) + " does not match " + stringify(targetDomain));
                                        return normalizedDomain;
                                    });
                                });
                            }(win, domainMatcher, (void 0 === _temp ? {} : _temp).domain, {
                                send: send
                            });
                        }).then(function(targetDomain) {
                            var domain = targetDomain;
                            var logName = "postrobot_method" === name && data && "string" == typeof data.name ? data.name + "()" : name;
                            var promise = new promise_ZalgoPromise;
                            var hash = name + "_" + uniqueID();
                            if (!fireAndForget) {
                                var responseListener = {
                                    name: name,
                                    win: win,
                                    domain: domain,
                                    promise: promise
                                };
                                !function(hash, listener) {
                                    globalStore("responseListeners").set(hash, listener);
                                }(hash, responseListener);
                                var reqPromises = windowStore("requestPromises").getOrSet(win, function() {
                                    return [];
                                });
                                reqPromises.push(promise);
                                promise.catch(function() {
                                    !function(hash) {
                                        globalStore("erroredResponseListeners").set(hash, !0);
                                    }(hash);
                                    deleteResponseListener(hash);
                                });
                                var totalAckTimeout = function(win) {
                                    return windowStore("knownWindows").get(win, !1);
                                }(win) ? 1e4 : 2e3;
                                var totalResTimeout = responseTimeout;
                                var ackTimeout = totalAckTimeout;
                                var resTimeout = totalResTimeout;
                                var interval = function(method, time) {
                                    var timeout;
                                    !function loop() {
                                        timeout = setTimeout(function() {
                                            !function() {
                                                if (isWindowClosed(win)) return promise.reject(new Error("Window closed for " + name + " before " + (responseListener.ack ? "response" : "ack")));
                                                if (responseListener.cancelled) return promise.reject(new Error("Response listener was cancelled for " + name));
                                                ackTimeout = Math.max(ackTimeout - 500, 0);
                                                -1 !== resTimeout && (resTimeout = Math.max(resTimeout - 500, 0));
                                                responseListener.ack || 0 !== ackTimeout ? 0 === resTimeout && promise.reject(new Error("No response for postMessage " + logName + " in " + getDomain() + " in " + totalResTimeout + "ms")) : promise.reject(new Error("No ack for postMessage " + logName + " in " + getDomain() + " in " + totalAckTimeout + "ms"));
                                            }();
                                            loop();
                                        }, 500);
                                    }();
                                    return {
                                        cancel: function() {
                                            clearTimeout(timeout);
                                        }
                                    };
                                }();
                                promise.finally(function() {
                                    interval.cancel();
                                    reqPromises.splice(reqPromises.indexOf(promise, 1));
                                }).catch(src_util_noop);
                            }
                            return send_sendMessage(win, domain, {
                                id: uniqueID(),
                                origin: getDomain(window),
                                type: "postrobot_message_request",
                                hash: hash,
                                name: name,
                                data: data,
                                fireAndForget: fireAndForget
                            }, {
                                on: on_on,
                                send: send
                            }).then(function() {
                                return fireAndForget ? promise.resolve() : promise;
                            }, function(err) {
                                throw new Error("Send request message failed for " + logName + " in " + getDomain() + "\n\n" + stringifyError(err));
                            });
                        });
                    });
                };
                function setup_serializeMessage(destination, domain, obj) {
                    return serializeMessage(destination, domain, obj, {
                        on: on_on,
                        send: send_send
                    });
                }
                function setup_deserializeMessage(source, origin, message) {
                    return deserializeMessage(source, origin, message, {
                        on: on_on,
                        send: send_send
                    });
                }
                function createProxyWindow(win) {
                    return new window_ProxyWindow({
                        send: send_send,
                        win: win
                    });
                }
                function setup_toProxyWindow(win) {
                    return window_ProxyWindow.toProxyWindow(win, {
                        send: send_send
                    });
                }
                function setup() {
                    if (!global_getGlobal().initialized) {
                        global_getGlobal().initialized = !0;
                        on = (_ref3 = {
                            on: on_on,
                            send: send_send
                        }).on, send = _ref3.send, (global1 = global_getGlobal()).receiveMessage = global1.receiveMessage || function(message) {
                            return receive_receiveMessage(message, {
                                on: on,
                                send: send
                            });
                        };
                        !function(_ref5) {
                            var on = _ref5.on, send = _ref5.send;
                            globalStore().getOrSet("postMessageListener", function() {
                                return function(obj, event, handler) {
                                    obj.addEventListener("message", handler);
                                    return {
                                        cancel: function() {
                                            obj.removeEventListener("message", handler);
                                        }
                                    };
                                }(window, 0, function(event) {
                                    !function(event, _ref4) {
                                        var on = _ref4.on, send = _ref4.send;
                                        promise_ZalgoPromise.try(function() {
                                            var source = event.source || event.sourceElement;
                                            var origin = event.origin || event.originalEvent && event.originalEvent.origin;
                                            var data = event.data;
                                            "null" === origin && (origin = "file://");
                                            if (source) {
                                                if (!origin) throw new Error("Post message did not have origin domain");
                                                receive_receiveMessage({
                                                    source: source,
                                                    origin: origin,
                                                    data: data
                                                }, {
                                                    on: on,
                                                    send: send
                                                });
                                            }
                                        });
                                    }(event, {
                                        on: on,
                                        send: send
                                    });
                                });
                            });
                        }({
                            on: on_on,
                            send: send_send
                        });
                        !function(_ref8) {
                            var on = _ref8.on, send = _ref8.send;
                            globalStore("builtinListeners").getOrSet("helloListener", function() {
                                var listener = on("postrobot_hello", {
                                    domain: "*"
                                }, function(_ref3) {
                                    resolveHelloPromise(_ref3.source, {
                                        domain: _ref3.origin
                                    });
                                    return {
                                        instanceID: getInstanceID()
                                    };
                                });
                                var parent = getAncestor();
                                parent && sayHello(parent, {
                                    send: send
                                }).catch(function(err) {});
                                return listener;
                            });
                        }({
                            on: on_on,
                            send: send_send
                        });
                    }
                    var _ref3, on, send, global1;
                }
                function destroy() {
                    !function() {
                        var responseListeners = globalStore("responseListeners");
                        for(var _i2 = 0, _responseListeners$ke2 = responseListeners.keys(); _i2 < _responseListeners$ke2.length; _i2++){
                            var hash = _responseListeners$ke2[_i2];
                            var listener = responseListeners.get(hash);
                            listener && (listener.cancelled = !0);
                            responseListeners.del(hash);
                        }
                    }();
                    (listener = globalStore().get("postMessageListener")) && listener.cancel();
                    var listener;
                    delete window.__post_robot_10_0_46__;
                }
                var src_types_TYPES_0 = !0;
                function cleanUpWindow(win) {
                    for(var _i2 = 0, _requestPromises$get2 = windowStore("requestPromises").get(win, []); _i2 < _requestPromises$get2.length; _i2++)_requestPromises$get2[_i2].reject(new Error("Window " + (isWindowClosed(win) ? "closed" : "cleaned up") + " before response")).catch(src_util_noop);
                }
                setup();
            }
        ]);
    });
})(postRobot);
var postRobotExports$1 = postRobot.exports;
/* @flow */ (function(module) {
    // $FlowFixMe
    module.exports = postRobotExports$1; // eslint-disable-line import/no-commonjs
    // $FlowFixMe
    module.exports.default = module.exports; // eslint-disable-line import/no-commonjs 
})(postRobot$1);
var postRobotExports = postRobot$1.exports;
var index = /*@__PURE__*/ getDefaultExportFromCjs(postRobotExports);
var index$1 = /*#__PURE__*/ _mergeNamespaces({
    __proto__: null,
    default: index
}, [
    postRobotExports
]);
;
}}),
}]);

//# sourceMappingURL=node_modules_a726b943._.js.map