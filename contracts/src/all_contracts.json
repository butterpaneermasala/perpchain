[
  {
    "name": "CCIPReceiver",
    "path": "CCIPReceiver.sol",
    "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport {CCIPReceiver} from \"@chainlink/contracts/src/v0.8/ccip/applications/CCIPReceiver.sol\";\nimport {Client} from \"@chainlink/contracts/src/v0.8/ccip/libraries/Client.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport {Pausable} from \"@openzeppelin/contracts/utils/Pausable.sol\";\nimport {AccessControl} from \"@openzeppelin/contracts/access/AccessControl.sol\";\n\n// Add missing interface for lending pool\ninterface ICrossChainLendingPool {\n    // Define any required functions here, or leave empty if not used directly\n}\n\ninterface ICrossChainVault {\n    function depositFromCCIP(\n        address user,\n        address token,\n        uint256 amount\n    ) external;\n\n    function withdrawToCCIP(\n        address user,\n        address token,\n        uint256 amount\n    ) external;\n\n    function updateUserBalance(\n        address user,\n        address token,\n        uint256 amount,\n        bool isDeposit\n    ) external;\n}\n\ninterface IPerpetualTrading {\n    function updatePositionFromCCIP(\n        address user,\n        bytes32 positionId,\n        uint256 size,\n        uint256 collateral,\n        bool isLong,\n        uint256 entryPrice\n    ) external;\n\n    function liquidatePositionFromCCIP(\n        bytes32 positionId,\n        address liquidator\n    ) external;\n}\n\n/**\n * @title CrossChainReceiver\n * @dev Handles incoming cross-chain messages for the perpetual trading platform\n * @notice This contract receives and processes cross-chain asset transfers and position updates\n */\ncontract CrossChainReceiver is\n    CCIPReceiver,\n    ReentrancyGuard,\n    Pausable,\n    AccessControl\n{\n    using SafeERC20 for IERC20;\n\n    // Role definitions\n    bytes32 public constant ADMIN_ROLE = keccak256(\"ADMIN_ROLE\");\n    bytes32 public constant OPERATOR_ROLE = keccak256(\"OPERATOR_ROLE\");\n\n    // Message types\n    enum MessageType {\n        ASSET_DEPOSIT,\n        ASSET_WITHDRAWAL,\n        POSITION_UPDATE,\n        POSITION_LIQUIDATION,\n        EMERGENCY_STOP\n    }\n\n    // Structs for different message types\n    struct AssetMessage {\n        address user;\n        address token;\n        uint256 amount;\n        uint256 nonce;\n    }\n\n    struct PositionMessage {\n        address user;\n        bytes32 positionId;\n        uint256 size;\n        uint256 collateral;\n        bool isLong;\n        uint256 entryPrice;\n        uint256 nonce;\n    }\n\n    struct LiquidationMessage {\n        bytes32 positionId;\n        address liquidator;\n        uint256 nonce;\n    }\n\n    // Contract interfaces\n    ICrossChainVault public immutable vault;\n    IPerpetualTrading public immutable perpetualTrading;\n    ICrossChainLendingPool public lendingPool;\n\n    // State variables\n    mapping(uint64 => bool) public allowedSourceChains;\n    mapping(address => bool) public allowedSenders;\n    mapping(bytes32 => bool) public processedMessages;\n    mapping(address => uint256) public userNonces;\n\n    // Security constants\n    uint256 public constant MAX_MESSAGE_AGE = 1 hours;\n    uint256 public constant MIN_CONFIRMATION_DELAY = 10 minutes;\n\n    // Events\n    event MessageReceived(\n        bytes32 indexed messageId,\n        uint64 indexed sourceChainSelector,\n        address indexed sender,\n        MessageType messageType\n    );\n\n    event AssetProcessed(\n        address indexed user,\n        address indexed token,\n        uint256 amount,\n        bool isDeposit,\n        uint256 nonce\n    );\n\n    event PositionUpdated(\n        address indexed user,\n        bytes32 indexed positionId,\n        uint256 size,\n        uint256 collateral,\n        uint256 nonce\n    );\n\n    event PositionLiquidated(\n        bytes32 indexed positionId,\n        address indexed liquidator,\n        uint256 nonce\n    );\n\n    event ChainAllowlistUpdated(uint64 chainSelector, bool allowed);\n    event SenderAllowlistUpdated(address sender, bool allowed);\n\n    // Errors\n    error InvalidSourceChain(uint64 sourceChainSelector);\n    error InvalidSender(address sender);\n    error MessageAlreadyProcessed(bytes32 messageId);\n    error InvalidMessageType();\n    error InvalidNonce(uint256 expected, uint256 received);\n    error InsufficientTokens(\n        address token,\n        uint256 required,\n        uint256 available\n    );\n    error InvalidMessageData();\n    error MessageTooOld();\n    error ZeroAddress();\n\n    /**\n     * @dev Constructor\n     * @param _router CCIP router address\n     * @param _vault CrossChainVault contract address\n     * @param _perpetualTrading PerpetualTrading contract address\n     */\n    constructor(\n        address _router,\n        address _vault,\n        address _perpetualTrading,\n        address _lendingPool\n    ) CCIPReceiver(_router) {\n        if (_vault == address(0)) revert ZeroAddress();\n        if (_perpetualTrading == address(0)) revert ZeroAddress();\n\n        vault = ICrossChainVault(_vault);\n        perpetualTrading = IPerpetualTrading(_perpetualTrading);\n        lendingPool = ICrossChainLendingPool(_lendingPool);\n\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\n        _grantRole(ADMIN_ROLE, msg.sender);\n        _grantRole(OPERATOR_ROLE, msg.sender);\n    }\n\n    //\n\n    /**\n     * @dev Receives and processes cross-chain messages\n     * @param any2EvmMessage The CCIP message\n     */\n    function _ccipReceive(\n        Client.Any2EVMMessage memory any2EvmMessage\n    ) internal override nonReentrant whenNotPaused {\n        // Validate source chain\n        if (!allowedSourceChains[any2EvmMessage.sourceChainSelector]) {\n            revert InvalidSourceChain(any2EvmMessage.sourceChainSelector);\n        }\n\n        // Validate sender\n        address sender = abi.decode(any2EvmMessage.sender, (address));\n        if (!allowedSenders[sender]) {\n            revert InvalidSender(sender);\n        }\n\n        // Check for message replay\n        bytes32 messageId = any2EvmMessage.messageId;\n        if (processedMessages[messageId]) {\n            revert MessageAlreadyProcessed(messageId);\n        }\n\n        // Mark message as processed immediately to prevent reentrancy\n        processedMessages[messageId] = true;\n\n        // Decode message type\n        (MessageType messageType, bytes memory messageData) = abi.decode(\n            any2EvmMessage.data,\n            (MessageType, bytes)\n        );\n\n        // Process based on message type\n        if (messageType == MessageType.ASSET_DEPOSIT) {\n            _processAssetDeposit(messageData, any2EvmMessage.destTokenAmounts);\n        } else if (messageType == MessageType.ASSET_WITHDRAWAL) {\n            _processAssetWithdrawal(messageData);\n        } else if (messageType == MessageType.POSITION_UPDATE) {\n            _processPositionUpdate(messageData);\n        } else if (messageType == MessageType.POSITION_LIQUIDATION) {\n            _processPositionLiquidation(messageData);\n        } else if (messageType == MessageType.EMERGENCY_STOP) {\n            _processEmergencyStop();\n        } else {\n            revert InvalidMessageType();\n        }\n\n        emit MessageReceived(\n            messageId,\n            any2EvmMessage.sourceChainSelector,\n            sender,\n            messageType\n        );\n    }\n\n    /**\n     * @dev Processes asset deposit messages\n     */\n    function _processAssetDeposit(\n        bytes memory messageData,\n        Client.EVMTokenAmount[] memory tokenAmounts\n    ) internal {\n        AssetMessage memory assetMsg = abi.decode(messageData, (AssetMessage));\n\n        // Validate nonce\n        uint256 expectedNonce = userNonces[assetMsg.user] + 1;\n        if (assetMsg.nonce != expectedNonce) {\n            revert InvalidNonce(expectedNonce, assetMsg.nonce);\n        }\n\n        // Validate token amounts\n        if (tokenAmounts.length != 1) {\n            revert InvalidMessageData();\n        }\n\n        Client.EVMTokenAmount memory tokenAmount = tokenAmounts[0];\n        if (\n            tokenAmount.token != assetMsg.token ||\n            tokenAmount.amount != assetMsg.amount\n        ) {\n            revert InvalidMessageData();\n        }\n\n        // Update user nonce before external call\n        userNonces[assetMsg.user] = assetMsg.nonce;\n\n        // Process deposit in vault\n        vault.depositFromCCIP(assetMsg.user, assetMsg.token, assetMsg.amount);\n\n        emit AssetProcessed(\n            assetMsg.user,\n            assetMsg.token,\n            assetMsg.amount,\n            true,\n            assetMsg.nonce\n        );\n    }\n\n    /**\n     * @dev Processes asset withdrawal messages\n     */\n    function _processAssetWithdrawal(bytes memory messageData) internal {\n        AssetMessage memory assetMsg = abi.decode(messageData, (AssetMessage));\n\n        // Validate nonce\n        uint256 expectedNonce = userNonces[assetMsg.user] + 1;\n        if (assetMsg.nonce != expectedNonce) {\n            revert InvalidNonce(expectedNonce, assetMsg.nonce);\n        }\n\n        // Update user nonce before external call\n        userNonces[assetMsg.user] = assetMsg.nonce;\n\n        // Process withdrawal from vault\n        vault.withdrawToCCIP(assetMsg.user, assetMsg.token, assetMsg.amount);\n\n        emit AssetProcessed(\n            assetMsg.user,\n            assetMsg.token,\n            assetMsg.amount,\n            false,\n            assetMsg.nonce\n        );\n    }\n\n    /**\n     * @dev Processes position update messages\n     */\n    function _processPositionUpdate(bytes memory messageData) internal {\n        PositionMessage memory posMsg = abi.decode(\n            messageData,\n            (PositionMessage)\n        );\n\n        // Validate nonce\n        uint256 expectedNonce = userNonces[posMsg.user] + 1;\n        if (posMsg.nonce != expectedNonce) {\n            revert InvalidNonce(expectedNonce, posMsg.nonce);\n        }\n\n        // Update user nonce before external call\n        userNonces[posMsg.user] = posMsg.nonce;\n\n        // Update position in perpetual trading contract\n        perpetualTrading.updatePositionFromCCIP(\n            posMsg.user,\n            posMsg.positionId,\n            posMsg.size,\n            posMsg.collateral,\n            posMsg.isLong,\n            posMsg.entryPrice\n        );\n\n        emit PositionUpdated(\n            posMsg.user,\n            posMsg.positionId,\n            posMsg.size,\n            posMsg.collateral,\n            posMsg.nonce\n        );\n    }\n\n    /**\n     * @dev Processes position liquidation messages\n     */\n    function _processPositionLiquidation(bytes memory messageData) internal {\n        LiquidationMessage memory liqMsg = abi.decode(\n            messageData,\n            (LiquidationMessage)\n        );\n\n        // Process liquidation\n        perpetualTrading.liquidatePositionFromCCIP(\n            liqMsg.positionId,\n            liqMsg.liquidator\n        );\n\n        emit PositionLiquidated(\n            liqMsg.positionId,\n            liqMsg.liquidator,\n            liqMsg.nonce\n        );\n    }\n\n    /**\n     * @dev Processes emergency stop messages\n     */\n    function _processEmergencyStop() internal {\n        _pause();\n    }\n\n    /**\n     * @dev Allows or disallows a source chain\n     * @param chainSelector Chain selector to update\n     * @param allowed Whether the chain is allowed\n     */\n    function setAllowedSourceChain(\n        uint64 chainSelector,\n        bool allowed\n    ) external onlyRole(ADMIN_ROLE) {\n        allowedSourceChains[chainSelector] = allowed;\n        emit ChainAllowlistUpdated(chainSelector, allowed);\n    }\n\n    /**\n     * @dev Allows or disallows a sender address\n     * @param sender Sender address to update\n     * @param allowed Whether the sender is allowed\n     */\n    function setAllowedSender(\n        address sender,\n        bool allowed\n    ) external onlyRole(ADMIN_ROLE) {\n        if (sender == address(0)) revert ZeroAddress();\n        allowedSenders[sender] = allowed;\n        emit SenderAllowlistUpdated(sender, allowed);\n    }\n\n    /**\n     * @dev Pauses the contract\n     */\n    function pause() external onlyRole(ADMIN_ROLE) {\n        _pause();\n    }\n\n    /**\n     * @dev Unpauses the contract\n     */\n    function unpause() external onlyRole(ADMIN_ROLE) {\n        _unpause();\n    }\n\n    /**\n     * @dev Emergency token recovery\n     * @param token Token address to recover\n     * @param amount Amount to recover\n     * @param to Address to send tokens to\n     */\n    function emergencyTokenRecovery(\n        address token,\n        uint256 amount,\n        address to\n    ) external onlyRole(ADMIN_ROLE) {\n        if (to == address(0)) revert ZeroAddress();\n        IERC20(token).safeTransfer(to, amount);\n    }\n\n    /**\n     * @dev Gets the current nonce for a user\n     * @param user User address\n     * @return Current nonce\n     */\n    function getUserNonce(address user) external view returns (uint256) {\n        return userNonces[user];\n    }\n\n    /**\n     * @dev Checks if a message has been processed\n     * @param messageId Message ID to check\n     * @return Whether the message has been processed\n     */\n    function isMessageProcessed(\n        bytes32 messageId\n    ) external view returns (bool) {\n        return processedMessages[messageId];\n    }\n\n    /**\n     * @dev Checks if a source chain is allowed\n     * @param chainSelector Chain selector to check\n     * @return Whether the chain is allowed\n     */\n    function isSourceChainAllowed(\n        uint64 chainSelector\n    ) external view returns (bool) {\n        return allowedSourceChains[chainSelector];\n    }\n\n    /**\n     * @dev Checks if a sender is allowed\n     * @param sender Sender address to check\n     * @return Whether the sender is allowed\n     */\n    function isSenderAllowed(address sender) external view returns (bool) {\n        return allowedSenders[sender];\n    }\n\n    function supportsInterface(\n        bytes4 interfaceId\n    ) public view virtual override(AccessControl, CCIPReceiver) returns (bool) {\n        return\n            AccessControl.supportsInterface(interfaceId) ||\n            CCIPReceiver.supportsInterface(interfaceId);\n    }\n}\n"
  },
  {
    "name": "CrossChainVault",
    "path": "CrossChainVault.sol",
    "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {Pausable} from \"@openzeppelin/contracts/utils/Pausable.sol\";\nimport {IRouterClient} from \"@chainlink/contracts/src/v0.8/ccip/interfaces/IRouterClient.sol\";\nimport {Client} from \"@chainlink/contracts/src/v0.8/ccip/libraries/Client.sol\";\n\n/**\n * @title CrossChainVault\n * @dev Manages user assets across multiple blockchains using Chainlink CCIP\n */\ncontract CrossChainVault is ReentrancyGuard, Ownable, Pausable {\n    using SafeERC20 for IERC20;\n\n    // ============ STRUCTS ============\n\n    struct UserBalance {\n        uint256 totalDeposited;\n        uint256 availableBalance;\n        uint256 lockedBalance;\n        mapping(address => uint256) tokenBalances;\n    }\n\n    struct CrossChainTransfer {\n        bytes32 transferId;\n        address user;\n        address token;\n        uint256 amount;\n        uint64 destinationChainSelector;\n        bool completed;\n        uint256 timestamp;\n    }\n\n    // ============ STATE VARIABLES ============\n\n    IRouterClient public router;\n    mapping(address => UserBalance) public userBalances;\n    mapping(bytes32 => CrossChainTransfer) public crossChainTransfers;\n    mapping(address => bool) public supportedTokens;\n    mapping(uint64 => bool) public supportedChains;\n    mapping(address => bool) public authorizedCallers;\n\n    // Security constants\n    uint256 public constant MAX_TRANSFER_AMOUNT = 1000000 * 1e18; // 1M tokens max\n    uint256 public constant MIN_TRANSFER_AMOUNT = 1e18; // 1 token min\n    uint256 public constant TRANSFER_TIMEOUT = 24 hours;\n\n    // ============ CONSTRUCTOR ============\n\n    constructor(address _router) Ownable(msg.sender) {\n        require(_router != address(0), \"Invalid router address\");\n        router = IRouterClient(_router);\n    }\n\n    // ============ EVENTS ============\n\n    event Deposit(address indexed user, address indexed token, uint256 amount);\n    event Withdraw(address indexed user, address indexed token, uint256 amount);\n    event CrossChainTransferInitiated(\n        bytes32 indexed transferId,\n        address indexed user,\n        address token,\n        uint256 amount,\n        uint64 destinationChainSelector\n    );\n    event CrossChainTransferCompleted(\n        bytes32 indexed transferId,\n        address indexed user,\n        address token,\n        uint256 amount\n    );\n    event CrossChainTransferReverted(\n        bytes32 indexed transferId,\n        address indexed user,\n        address token,\n        uint256 amount\n    );\n\n    // ============ MODIFIERS ============\n\n    modifier onlySupportedToken(address token) {\n        require(supportedTokens[token], \"Token not supported\");\n        _;\n    }\n\n    modifier onlySupportedChain(uint64 chainSelector) {\n        require(supportedChains[chainSelector], \"Chain not supported\");\n        _;\n    }\n\n    modifier onlyAuthorizedCaller() {\n        require(\n            authorizedCallers[msg.sender] || msg.sender == owner(),\n            \"Not authorized\"\n        );\n        _;\n    }\n\n    // ============ CORE FUNCTIONS ============\n\n    /**\n     * @dev Deposit tokens into the vault\n     * @param token Token address to deposit\n     * @param amount Amount to deposit\n     */\n    function deposit(\n        address token,\n        uint256 amount\n    ) external nonReentrant whenNotPaused onlySupportedToken(token) {\n        require(amount > 0, \"Amount must be greater than 0\");\n        require(amount <= MAX_TRANSFER_AMOUNT, \"Amount exceeds maximum\");\n\n        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n\n        // FIX: Update userBalances mapping\n        UserBalance storage balance = userBalances[msg.sender];\n        balance.totalDeposited += amount;\n        balance.availableBalance += amount;\n        balance.tokenBalances[token] += amount;\n\n        emit Deposit(msg.sender, token, amount);\n    }\n\n    function withdraw(\n        address token,\n        uint256 amount\n    ) external nonReentrant whenNotPaused onlySupportedToken(token) {\n        require(amount > 0, \"Amount must be greater than 0\");\n        UserBalance storage balance = userBalances[msg.sender];\n        require(\n            balance.availableBalance >= amount,\n            \"Insufficient available balance\"\n        );\n        require(\n            balance.tokenBalances[token] >= amount,\n            \"Insufficient token balance\"\n        );\n\n        // FIX: Update balances BEFORE transfer\n        balance.totalDeposited -= amount;\n        balance.availableBalance -= amount;\n        balance.tokenBalances[token] -= amount;\n\n        IERC20(token).safeTransfer(msg.sender, amount);\n        emit Withdraw(msg.sender, token, amount);\n    }\n\n    /**\n     * @dev Initiate cross-chain transfer\n     * @param token Token address to transfer\n     * @param amount Amount to transfer\n     * @param destinationChainSelector Destination chain selector\n     * @param receiver Receiver address on destination chain\n     */\n    function initiateCrossChainTransfer(\n        address token,\n        uint256 amount,\n        uint64 destinationChainSelector,\n        address receiver\n    )\n        external\n        payable\n        nonReentrant\n        whenNotPaused\n        onlySupportedToken(token)\n        onlySupportedChain(destinationChainSelector)\n    {\n        require(amount >= MIN_TRANSFER_AMOUNT, \"Amount below minimum\");\n        require(amount <= MAX_TRANSFER_AMOUNT, \"Amount exceeds maximum\");\n        require(receiver != address(0), \"Invalid receiver address\");\n\n        UserBalance storage balance = userBalances[msg.sender];\n        require(\n            balance.availableBalance >= amount,\n            \"Insufficient available balance\"\n        );\n        require(\n            balance.tokenBalances[token] >= amount,\n            \"Insufficient token balance\"\n        );\n\n        // Lock user's balance before external call\n        balance.availableBalance -= amount;\n        balance.lockedBalance += amount;\n        balance.tokenBalances[token] -= amount;\n\n        // Create transfer record\n        bytes32 transferId = keccak256(\n            abi.encodePacked(\n                msg.sender,\n                token,\n                amount,\n                destinationChainSelector,\n                block.timestamp,\n                block.number\n            )\n        );\n\n        crossChainTransfers[transferId] = CrossChainTransfer({\n            transferId: transferId,\n            user: msg.sender,\n            token: token,\n            amount: amount,\n            destinationChainSelector: destinationChainSelector,\n            completed: false,\n            timestamp: block.timestamp\n        });\n\n        // Prepare CCIP message\n        Client.EVM2AnyMessage memory message = Client.EVM2AnyMessage({\n            receiver: abi.encode(receiver),\n            data: abi.encode(msg.sender, token, amount),\n            tokenAmounts: new Client.EVMTokenAmount[](1),\n            extraArgs: \"\",\n            feeToken: address(0)\n        });\n\n        message.tokenAmounts[0] = Client.EVMTokenAmount({\n            token: token,\n            amount: amount\n        });\n\n        // Calculate and check fee\n        uint256 fee = router.getFee(destinationChainSelector, message);\n        require(msg.value >= fee, \"Insufficient fee\");\n\n        // Send CCIP message\n        router.ccipSend{value: fee}(destinationChainSelector, message);\n\n        // Refund excess fee\n        if (msg.value > fee) {\n            payable(msg.sender).transfer(msg.value - fee);\n        }\n\n        emit CrossChainTransferInitiated(\n            transferId,\n            msg.sender,\n            token,\n            amount,\n            destinationChainSelector\n        );\n    }\n\n    /**\n     * @dev Finalize a cross-chain transfer (called by authorized caller)\n     * @param transferId The transfer ID\n     */\n    function finalizeCrossChainTransfer(\n        bytes32 transferId\n    ) external onlyAuthorizedCaller {\n        CrossChainTransfer storage transfer = crossChainTransfers[transferId];\n        require(!transfer.completed, \"Transfer already completed\");\n        require(transfer.user != address(0), \"Invalid transfer\");\n\n        UserBalance storage balance = userBalances[transfer.user];\n        require(\n            balance.lockedBalance >= transfer.amount,\n            \"Insufficient locked balance\"\n        );\n\n        balance.lockedBalance -= transfer.amount;\n        transfer.completed = true;\n\n        emit CrossChainTransferCompleted(\n            transferId,\n            transfer.user,\n            transfer.token,\n            transfer.amount\n        );\n    }\n\n    /**\n     * @dev Revert a cross-chain transfer (in case of failure)\n     * @param transferId The transfer ID\n     */\n    function revertCrossChainTransfer(\n        bytes32 transferId\n    ) external onlyAuthorizedCaller {\n        CrossChainTransfer storage transfer = crossChainTransfers[transferId];\n        require(!transfer.completed, \"Transfer already completed\");\n        require(transfer.user != address(0), \"Invalid transfer\");\n\n        UserBalance storage balance = userBalances[transfer.user];\n        require(\n            balance.lockedBalance >= transfer.amount,\n            \"Insufficient locked balance\"\n        );\n\n        balance.lockedBalance -= transfer.amount;\n        balance.availableBalance += transfer.amount;\n        balance.tokenBalances[transfer.token] += transfer.amount;\n        transfer.completed = true;\n\n        emit CrossChainTransferReverted(\n            transferId,\n            transfer.user,\n            transfer.token,\n            transfer.amount\n        );\n    }\n\n    /**\n     * @dev Deposit from CCIP (called by authorized caller)\n     */\n    function depositFromCCIP(\n        address user,\n        address token,\n        uint256 amount\n    ) external onlyAuthorizedCaller onlySupportedToken(token) {\n        require(user != address(0), \"Invalid user address\");\n        require(amount > 0, \"Amount must be greater than 0\");\n\n        UserBalance storage balance = userBalances[user];\n        balance.totalDeposited += amount;\n        balance.availableBalance += amount;\n        balance.tokenBalances[token] += amount;\n\n        emit Deposit(user, token, amount);\n    }\n\n    /**\n     * @dev Withdraw to CCIP (called by authorized caller)\n     */\n    function withdrawToCCIP(\n        address user,\n        address token,\n        uint256 amount\n    ) external onlyAuthorizedCaller onlySupportedToken(token) {\n        require(user != address(0), \"Invalid user address\");\n        require(amount > 0, \"Amount must be greater than 0\");\n\n        UserBalance storage balance = userBalances[user];\n        require(\n            balance.availableBalance >= amount,\n            \"Insufficient available balance\"\n        );\n        require(\n            balance.tokenBalances[token] >= amount,\n            \"Insufficient token balance\"\n        );\n\n        balance.totalDeposited -= amount;\n        balance.availableBalance -= amount;\n        balance.tokenBalances[token] -= amount;\n\n        IERC20(token).safeTransfer(user, amount);\n\n        emit Withdraw(user, token, amount);\n    }\n\n    // ============ VIEW FUNCTIONS ============\n\n    /**\n     * @dev Get user's token balance\n     * @param user User address\n     * @param token Token address\n     * @return balance User's token balance\n     */\n    function getUserTokenBalance(\n        address user,\n        address token\n    ) external view returns (uint256 balance) {\n        return userBalances[user].tokenBalances[token];\n    }\n\n    /**\n     * @dev Get user's total balance info\n     * @param user User address\n     * @return totalDeposited Total amount deposited\n     * @return availableBalance Available balance\n     * @return lockedBalance Locked balance\n     */\n    function getUserBalanceInfo(\n        address user\n    )\n        external\n        view\n        returns (\n            uint256 totalDeposited,\n            uint256 availableBalance,\n            uint256 lockedBalance\n        )\n    {\n        UserBalance storage balance = userBalances[user];\n        return (\n            balance.totalDeposited,\n            balance.availableBalance,\n            balance.lockedBalance\n        );\n    }\n\n    // ============ ADMIN FUNCTIONS ============\n\n    /**\n     * @dev Add supported token\n     * @param token Token address\n     */\n    function addSupportedToken(address token) external onlyOwner {\n        require(token != address(0), \"Invalid token address\");\n        supportedTokens[token] = true;\n    }\n\n    /**\n     * @dev Remove supported token\n     * @param token Token address\n     */\n    function removeSupportedToken(address token) external onlyOwner {\n        supportedTokens[token] = false;\n    }\n\n    /**\n     * @dev Add supported chain\n     * @param chainSelector Chain selector\n     */\n    function addSupportedChain(uint64 chainSelector) external onlyOwner {\n        require(chainSelector != 0, \"Invalid chain selector\");\n        supportedChains[chainSelector] = true;\n    }\n\n    /**\n     * @dev Remove supported chain\n     * @param chainSelector Chain selector\n     */\n    function removeSupportedChain(uint64 chainSelector) external onlyOwner {\n        supportedChains[chainSelector] = false;\n    }\n\n    /**\n     * @dev Update router address\n     * @param _router New router address\n     */\n    function updateRouter(address _router) external onlyOwner {\n        require(_router != address(0), \"Invalid router address\");\n        router = IRouterClient(_router);\n    }\n\n    /**\n     * @dev Set authorized caller\n     * @param caller Caller address\n     * @param authorized Whether the caller is authorized\n     */\n    function setAuthorizedCaller(\n        address caller,\n        bool authorized\n    ) external onlyOwner {\n        require(caller != address(0), \"Invalid caller address\");\n        authorizedCallers[caller] = authorized;\n    }\n\n    /**\n     * @dev Pause the contract\n     */\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    /**\n     * @dev Unpause the contract\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    /**\n     * @dev Emergency withdraw\n     */\n    function emergencyWithdraw(\n        address token,\n        uint256 amount,\n        address to\n    ) external onlyOwner {\n        require(to != address(0), \"Invalid recipient\");\n        IERC20(token).safeTransfer(to, amount);\n    }\n\n    /**\n     * @dev Receive function to accept ETH for CCIP fees\n     */\n    receive() external payable {}\n}\n"
  },
  {
    "name": "DataStreamOracle",
    "path": "DataStreamOracle.sol",
    "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {Pausable} from \"@openzeppelin/contracts/utils/Pausable.sol\";\n\ninterface AggregatorV3Interface {\n    function latestRoundData()\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n    function decimals() external view returns (uint8);\n}\n\ncontract DataStreamOracle is Ownable(msg.sender), Pausable {\n    // ===== Structs =====\n    struct PriceData {\n        uint256 price;\n        uint256 timestamp;\n        uint256 roundId;\n        uint8 decimals;\n        bool isActive;\n    }\n    struct TWAPData {\n        uint256 cumulativePrice;\n        uint256 lastTimestamp;\n        uint256 twapPrice;\n        uint256 windowSize;\n    }\n    struct FeedConfig {\n        string symbol;\n        uint8 decimals;\n        uint256 heartbeat;\n        uint256 deviationThreshold;\n        bool isActive;\n        address fallbackFeed;\n    }\n    struct CircuitBreaker {\n        uint256 maxDeviationBps;\n        uint256 cooldownPeriod;\n        uint256 lastTriggered;\n        bool isEnabled;\n    }\n\n    // ===== State =====\n    mapping(bytes32 => PriceData) public priceFeeds;\n    mapping(bytes32 => TWAPData) public twapData;\n    mapping(bytes32 => FeedConfig) public feedConfigs;\n    mapping(bytes32 => CircuitBreaker) public circuitBreakers;\n    mapping(address => bool) public authorizedUpdaters;\n    mapping(address => bool) public priceValidators;\n    bytes32[] public allFeeds;\n\n    // ===== Events =====\n    event PriceUpdated(bytes32 indexed feedId, uint256 price, uint256 timestamp, uint256 roundId);\n    event CircuitBreakerTriggered(bytes32 indexed feedId, uint256 oldPrice, uint256 newPrice);\n\n    // ===== Modifiers =====\n    modifier onlyAuthorized() {\n        require(authorizedUpdaters[msg.sender], \"Not authorized updater\");\n        _;\n    }\n    modifier validFeed(bytes32 feedId) {\n        require(feedConfigs[feedId].isActive, \"Feed not active\");\n        _;\n    }\n\n    // ===== Core Functions =====\n    function updatePrice(bytes32 feedId, uint256 price, uint256 timestamp, uint256 roundId) internal onlyAuthorized validFeed(feedId) whenNotPaused {\n        require(price > 0, \"Invalid price\");\n        require(timestamp <= block.timestamp, \"Future timestamp\");\n        FeedConfig storage config = feedConfigs[feedId];\n        require(config.isActive, \"Feed not active\");\n        PriceData storage pd = priceFeeds[feedId];\n        CircuitBreaker storage cb = circuitBreakers[feedId];\n        // Circuit breaker check\n        if (pd.price > 0 && cb.isEnabled) {\n            uint256 deviation = _calculateDeviation(pd.price, price);\n            if (deviation > cb.maxDeviationBps && block.timestamp > cb.lastTriggered + cb.cooldownPeriod) {\n                cb.lastTriggered = block.timestamp;\n                emit CircuitBreakerTriggered(feedId, pd.price, price);\n                revert(\"Circuit breaker triggered\");\n            }\n        }\n        // Update price\n        pd.price = price;\n        pd.timestamp = timestamp;\n        pd.roundId = roundId;\n        pd.decimals = config.decimals;\n        pd.isActive = true;\n        // Update TWAP\n        _updateTWAP(feedId, price, timestamp);\n        emit PriceUpdated(feedId, price, timestamp, roundId);\n    }\n\n    function updatePrices(bytes32[] calldata feedIds, uint256[] calldata prices, uint256[] calldata timestamps, uint256[] calldata roundIds) external onlyAuthorized whenNotPaused {\n        require(feedIds.length == prices.length && prices.length == timestamps.length && timestamps.length == roundIds.length, \"Array length mismatch\");\n        for (uint256 i = 0; i < feedIds.length; i++) {\n            updatePrice(feedIds[i], prices[i], timestamps[i], roundIds[i]);\n        }\n    }\n\n    function getLatestPrice(bytes32 feedId) external view validFeed(feedId) returns (uint256 price, uint256 timestamp, uint256 roundId) {\n        PriceData storage pd = priceFeeds[feedId];\n        FeedConfig storage config = feedConfigs[feedId];\n        // Staleness check\n        if (block.timestamp - pd.timestamp > config.heartbeat) {\n            // Fallback\n            (price, timestamp, roundId) = _getFallbackPrice(feedId);\n        } else {\n            price = pd.price;\n            timestamp = pd.timestamp;\n            roundId = pd.roundId;\n        }\n    }\n\n    function getTWAPPrice(bytes32 feedId) external view validFeed(feedId) returns (uint256 twapPrice) {\n        TWAPData storage td = twapData[feedId];\n        twapPrice = td.twapPrice;\n    }\n\n    function getValidatedPrice(bytes32 feedId) external view returns (uint256 price, uint256 timestamp, bool isValid) {\n        FeedConfig storage config = feedConfigs[feedId];\n        PriceData storage pd = priceFeeds[feedId];\n        isValid = false;\n        if (!config.isActive) return (0, 0, false);\n        if (pd.price == 0) return (0, 0, false);\n        if (block.timestamp - pd.timestamp > config.heartbeat) return (0, 0, false);\n        CircuitBreaker storage cb = circuitBreakers[feedId];\n        if (cb.isEnabled && block.timestamp < cb.lastTriggered + cb.cooldownPeriod) return (0, 0, false);\n        price = pd.price;\n        timestamp = pd.timestamp;\n        isValid = true;\n    }\n\n    // ===== TWAP Internal =====\n    function _updateTWAP(bytes32 feedId, uint256 price, uint256 timestamp) internal {\n        TWAPData storage td = twapData[feedId];\n        uint256 window = td.windowSize > 0 ? td.windowSize : 300; // default 5 min\n        if (td.lastTimestamp == 0) {\n            td.twapPrice = price;\n            td.cumulativePrice = price * window;\n            td.lastTimestamp = timestamp;\n            td.windowSize = window;\n        } else {\n            uint256 timeElapsed = timestamp - td.lastTimestamp;\n            if (timeElapsed > window) timeElapsed = window;\n            td.twapPrice = (td.twapPrice * (window - timeElapsed) + price * timeElapsed) / window;\n            td.cumulativePrice += price * timeElapsed;\n            td.lastTimestamp = timestamp;\n        }\n    }\n\n    // ===== Circuit Breaker Internal =====\n    function _calculateDeviation(uint256 oldPrice, uint256 newPrice) internal pure returns (uint256) {\n        if (oldPrice == 0) return 0;\n        if (newPrice > oldPrice) {\n            return ((newPrice - oldPrice) * 10000) / oldPrice;\n        } else {\n            return ((oldPrice - newPrice) * 10000) / oldPrice;\n        }\n    }\n\n    // ===== Fallback Logic =====\n    function _getFallbackPrice(bytes32 feedId) internal view returns (uint256 price, uint256 timestamp, uint256 roundId) {\n        FeedConfig storage config = feedConfigs[feedId];\n        require(config.fallbackFeed != address(0), \"No fallback feed\");\n        AggregatorV3Interface fallbackFeed = AggregatorV3Interface(config.fallbackFeed);\n        (uint80 rId, int256 answer, uint256 _startedAt, uint256 updatedAt, uint80 _answeredInRound) = fallbackFeed.latestRoundData();\n        require(answer > 0, \"Fallback price invalid\");\n        price = uint256(answer);\n        timestamp = updatedAt;\n        roundId = uint256(rId);\n    }\n\n    // ===== Chainlink Automation =====\n    function checkUpkeep(bytes calldata) external view returns (bool upkeepNeeded, bytes memory performData) {\n        bytes32[] memory staleFeeds = new bytes32[](allFeeds.length);\n        uint256 count = 0;\n        for (uint256 i = 0; i < allFeeds.length; i++) {\n            bytes32 feedId = allFeeds[i];\n            FeedConfig storage config = feedConfigs[feedId];\n            PriceData storage pd = priceFeeds[feedId];\n            if (config.isActive && block.timestamp - pd.timestamp > config.heartbeat) {\n                staleFeeds[count++] = feedId;\n            }\n        }\n        if (count > 0) {\n            bytes memory data = abi.encode(staleFeeds, count);\n            return (true, data);\n        }\n        return (false, \"\");\n    }\n\n    function performUpkeep(bytes calldata performData) external {\n        (bytes32[] memory staleFeeds, uint256 count) = abi.decode(performData, (bytes32[], uint256));\n        for (uint256 i = 0; i < count; i++) {\n            bytes32 feedId = staleFeeds[i];\n            // Try fallback update\n            (uint256 price, uint256 timestamp, uint256 roundId) = _getFallbackPrice(feedId);\n            PriceData storage pd = priceFeeds[feedId];\n            pd.price = price;\n            pd.timestamp = timestamp;\n            pd.roundId = roundId;\n            pd.isActive = true;\n            emit PriceUpdated(feedId, price, timestamp, roundId);\n        }\n    }\n\n    // ===== Admin Functions =====\n    function addFeed(string memory feedSymbol, string memory symbol, uint8 decimals, uint256 heartbeat, uint256 deviationThreshold, address fallbackFeed) external onlyOwner {\n        bytes32 feedId = keccak256(abi.encodePacked(feedSymbol));\n        require(!feedConfigs[feedId].isActive, \"Feed already exists\");\n        feedConfigs[feedId] = FeedConfig({\n            symbol: symbol,\n            decimals: decimals,\n            heartbeat: heartbeat,\n            deviationThreshold: deviationThreshold,\n            isActive: true,\n            fallbackFeed: fallbackFeed\n        });\n        circuitBreakers[feedId] = CircuitBreaker({\n            maxDeviationBps: deviationThreshold,\n            cooldownPeriod: 300,\n            lastTriggered: 0,\n            isEnabled: true\n        });\n        allFeeds.push(feedId);\n    }\n\n    function pauseFeed(bytes32 feedId) external onlyOwner {\n        feedConfigs[feedId].isActive = false;\n    }\n    function unpauseFeed(bytes32 feedId) external onlyOwner {\n        feedConfigs[feedId].isActive = true;\n    }\n    function setAuthorizedUpdater(address updater, bool authorized) external onlyOwner {\n        authorizedUpdaters[updater] = authorized;\n    }\n    function setPriceValidator(address validator, bool enabled) external onlyOwner {\n        priceValidators[validator] = enabled;\n    }\n    function emergencyUpdatePrice(bytes32 feedId, uint256 price, uint256 timestamp) external onlyOwner {\n        require(price > 0, \"Invalid price\");\n        require(timestamp <= block.timestamp, \"Future timestamp\");\n        PriceData storage pd = priceFeeds[feedId];\n        pd.price = price;\n        pd.timestamp = timestamp;\n        pd.roundId = pd.roundId + 1;\n        pd.isActive = true;\n        emit PriceUpdated(feedId, price, timestamp, pd.roundId);\n    }\n    function resetCircuitBreaker(bytes32 feedId) external onlyOwner {\n        circuitBreakers[feedId].lastTriggered = 0;\n    }\n\n    // ===== New Setter Functions =====\n    /**\n     * @notice Set the TWAP window size for a feed\n     * @param feedId The feed identifier\n     * @param windowSize The new window size in seconds\n     */\n    function setTWAPWindowSize(bytes32 feedId, uint256 windowSize) external onlyOwner validFeed(feedId) {\n        require(windowSize > 0, \"Window size must be positive\");\n        twapData[feedId].windowSize = windowSize;\n    }\n\n    /**\n     * @notice Set circuit breaker parameters for a feed\n     * @param feedId The feed identifier\n     * @param maxDeviationBps Maximum deviation in basis points\n     * @param cooldownPeriod Cooldown period in seconds\n     * @param isEnabled Whether the circuit breaker is enabled\n     */\n    function setCircuitBreakerParams(bytes32 feedId, uint256 maxDeviationBps, uint256 cooldownPeriod, bool isEnabled) external onlyOwner validFeed(feedId) {\n        CircuitBreaker storage cb = circuitBreakers[feedId];\n        cb.maxDeviationBps = maxDeviationBps;\n        cb.cooldownPeriod = cooldownPeriod;\n        cb.isEnabled = isEnabled;\n    }\n}\n"
  },
  {
    "name": "LendingPool",
    "path": "LendingPool.sol",
    "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IRouterClient} from \"@chainlink/contracts/src/v0.8/ccip/interfaces/IRouterClient.sol\";\nimport {Client} from \"@chainlink/contracts/src/v0.8/ccip/libraries/Client.sol\";\n\ncontract CrossChainLendingPool is Ownable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    struct PoolInfo {\n        uint256 totalDeposits;\n        uint256 totalBorrows;\n        uint256 totalInterest;\n        uint256 lastInterestUpdate;\n        uint256 interestRate; // Annualized in basis points (500 = 5%)\n    }\n\n    // CCIP Router for cross-chain messaging\n    IRouterClient public ccipRouter;\n    address public ccipReceiver;\n    address public perpetualTrading;\n\n    mapping(address => PoolInfo) public pools;\n    mapping(address => mapping(address => uint256)) public userDeposits;\n    mapping(bytes32 => bool) public processedMessages;\n\n    event Deposit(address indexed user, address indexed token, uint256 amount);\n    event Withdraw(address indexed user, address indexed token, uint256 amount);\n    event Borrow(address indexed trader, address indexed token, uint256 amount);\n    event Repay(\n        address indexed trader,\n        address indexed token,\n        uint256 amount,\n        uint256 interest\n    );\n    event CrossChainDepositInitiated(\n        address indexed user,\n        address token,\n        uint256 amount,\n        uint64 destinationChain\n    );\n    event CrossChainWithdrawInitiated(\n        address indexed user,\n        address token,\n        uint256 amount,\n        uint64 sourceChain\n    );\n\n    modifier onlySupportedToken(address token) {\n        require(pools[token].interestRate > 0, \"Token not supported\");\n        _;\n    }\n\n    modifier onlyCCIPReceiver() {\n        require(msg.sender == ccipReceiver, \"Not authorized\");\n        _;\n    }\n    modifier onlyPerpetualTrading() {\n        require(msg.sender == perpetualTrading, \"Not authorized\");\n        _;\n    }\n\n    constructor(address _ccipRouter) Ownable(msg.sender) {\n        ccipRouter = IRouterClient(_ccipRouter);\n    }\n\n    // ========== CCIP Configuration ==========\n    function setCCIPReceiver(address _receiver) external onlyOwner {\n        ccipReceiver = _receiver;\n    }\n\n    function setPerpetualTrading(address _perp) external onlyOwner {\n        perpetualTrading = _perp;\n    }\n\n    // ========== Cross-Chain Deposit ==========\n    function initiateCrossChainDeposit(\n        uint64 destinationChainSelector,\n        address token,\n        uint256 amount\n    ) external payable nonReentrant onlySupportedToken(token) {\n        require(amount > 0, \"Amount must be > 0\");\n        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n\n        // Build CCIP message\n        Client.EVM2AnyMessage memory message = Client.EVM2AnyMessage({\n            receiver: abi.encode(ccipReceiver),\n            data: abi.encode(msg.sender, token, amount, \"DEPOSIT\"),\n            tokenAmounts: new Client.EVMTokenAmount[](0),\n            extraArgs: \"\",\n            feeToken: address(0)\n        });\n\n        // Pay CCIP fees\n        uint256 fee = ccipRouter.getFee(destinationChainSelector, message);\n        require(msg.value >= fee, \"Insufficient CCIP fee\");\n\n        // Send message\n        bytes32 messageId = ccipRouter.ccipSend{value: fee}(\n            destinationChainSelector,\n            message\n        );\n\n        emit CrossChainDepositInitiated(\n            msg.sender,\n            token,\n            amount,\n            destinationChainSelector\n        );\n    }\n\n    // Called by CCIP Receiver on destination chain\n    function finalizeCrossChainDeposit(\n        address user,\n        address token,\n        uint256 amount,\n        bytes32 messageId\n    ) external onlySupportedToken(token) onlyCCIPReceiver {\n        require(!processedMessages[messageId], \"Message already processed\");\n        processedMessages[messageId] = true;\n        pools[token].totalDeposits += amount;\n        userDeposits[user][token] += amount;\n        emit Deposit(user, token, amount);\n    }\n\n    // ========== Cross-Chain Withdrawal ==========\n    function initiateCrossChainWithdrawal(\n        uint64 sourceChainSelector,\n        address token,\n        uint256 amount\n    ) external payable nonReentrant onlySupportedToken(token) {\n        require(\n            userDeposits[msg.sender][token] >= amount,\n            \"Insufficient deposit\"\n        );\n        _updateInterest(token);\n        userDeposits[msg.sender][token] -= amount;\n        pools[token].totalDeposits -= amount;\n\n        // Build CCIP message\n        Client.EVM2AnyMessage memory message = Client.EVM2AnyMessage({\n            receiver: abi.encode(ccipReceiver),\n            data: abi.encode(msg.sender, token, amount, \"WITHDRAW\"),\n            tokenAmounts: new Client.EVMTokenAmount[](0),\n            extraArgs: \"\",\n            feeToken: address(0)\n        });\n\n        // Pay CCIP fees\n        uint256 fee = ccipRouter.getFee(sourceChainSelector, message);\n        require(msg.value >= fee, \"Insufficient CCIP fee\");\n\n        // Send message\n        bytes32 messageId = ccipRouter.ccipSend{value: fee}(\n            sourceChainSelector,\n            message\n        );\n\n        emit CrossChainWithdrawInitiated(\n            msg.sender,\n            token,\n            amount,\n            sourceChainSelector\n        );\n    }\n\n    // Called by CCIP Receiver on source chain\n    function finalizeCrossChainWithdrawal(\n        address user,\n        address token,\n        uint256 amount,\n        bytes32 messageId\n    ) external onlySupportedToken(token) onlyCCIPReceiver {\n        require(!processedMessages[messageId], \"Message already processed\");\n        processedMessages[messageId] = true;\n        IERC20(token).safeTransfer(user, amount);\n        emit Withdraw(user, token, amount);\n    }\n\n    // ========== Core Lending Logic ==========\n    function addSupportedToken(\n        address token,\n        uint256 interestRate\n    ) external onlyOwner {\n        require(interestRate > 0, \"Interest rate must be positive\");\n        pools[token] = PoolInfo({\n            totalDeposits: 0,\n            totalBorrows: 0,\n            totalInterest: 0,\n            lastInterestUpdate: block.timestamp,\n            interestRate: interestRate\n        });\n    }\n\n    function borrow(\n        address token,\n        uint256 amount\n    ) external onlyPerpetualTrading onlySupportedToken(token) {\n        require(amount > 0, \"Amount must be > 0\");\n        require(\n            pools[token].totalDeposits - pools[token].totalBorrows >= amount,\n            \"Insufficient liquidity\"\n        );\n        _updateInterest(token);\n        pools[token].totalBorrows += amount;\n        IERC20(token).safeTransfer(msg.sender, amount);\n        emit Borrow(msg.sender, token, amount);\n    }\n\n    function repay(\n        address token,\n        uint256 amount\n    ) external onlyPerpetualTrading onlySupportedToken(token) {\n        require(amount > 0, \"Amount must be > 0\");\n        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n        _updateInterest(token);\n        uint256 interest = (amount * pools[token].interestRate) / 10000 / 365;\n        pools[token].totalBorrows -= amount;\n        pools[token].totalInterest += interest;\n        emit Repay(msg.sender, token, amount, interest);\n    }\n\n    // ========== Internal Functions ==========\n    function _updateInterest(address token) internal {\n        PoolInfo storage pool = pools[token];\n        uint256 timeElapsed = block.timestamp - pool.lastInterestUpdate;\n        if (timeElapsed > 0 && pool.totalBorrows > 0) {\n            uint256 accrued = (pool.totalBorrows *\n                pool.interestRate *\n                timeElapsed) / (10000 * 365 days);\n            pool.totalInterest += accrued;\n            pool.lastInterestUpdate = block.timestamp;\n        }\n    }\n\n    // ========== View Functions ==========\n    function getAvailableLiquidity(\n        address token\n    ) external view returns (uint256) {\n        return pools[token].totalDeposits - pools[token].totalBorrows;\n    }\n\n    function getUserDeposit(\n        address user,\n        address token\n    ) external view returns (uint256) {\n        return userDeposits[user][token];\n    }\n}\n"
  },
  {
    "name": "LiquidationEngine",
    "path": "LiquidationEngine.sol",
    "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport {AutomationCompatibleInterface} from \"@chainlink/contracts/src/v0.8/automation/AutomationCompatible.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport {Pausable} from \"@openzeppelin/contracts/utils/Pausable.sol\";\n\ninterface IPositionManager {\n    struct Position {\n        address trader;\n        address asset;\n        uint256 size;\n        uint256 collateral;\n        uint256 entryPrice;\n        int256 unrealizedPnl;\n        uint256 lastUpdateTime;\n        bool isLong;\n        bool isActive;\n    }\n\n    function getPosition(\n        uint256 positionId\n    ) external view returns (Position memory);\n\n    function closePosition(\n        uint256 positionId,\n        uint256 price,\n        address liquidator\n    ) external;\n\n    function getAllActivePositions() external view returns (uint256[] memory);\n\n    function updatePositionPnl(uint256 positionId, int256 pnl) external;\n}\n\ninterface IDataStreamOracle {\n    function getLatestPrice(\n        bytes32 feedId\n    ) external view returns (uint256 price, uint256 timestamp);\n\n    function getPriceWithValidation(\n        bytes32 feedId\n    ) external view returns (uint256 price, bool isValid);\n}\n\ninterface ICrossChainVault {\n    function getCollateralValue(\n        address user,\n        address token\n    ) external view returns (uint256);\n\n    function liquidateCollateral(\n        address user,\n        uint256 amount,\n        address liquidator\n    ) external;\n\n    function getTotalCollateralUSD(\n        address user\n    ) external view returns (uint256);\n}\n\n/**\n * @title LiquidationEngine\n * @dev Automated liquidation system for cross-chain perpetual trading platform\n * Integrates with Chainlink Automation for reliable liquidation triggers\n */\ncontract LiquidationEngine is\n    AutomationCompatibleInterface,\n    Ownable,\n    ReentrancyGuard,\n    Pausable\n{\n    // State Variables\n    IPositionManager public positionManager;\n\n    IDataStreamOracle public oracle;\n    ICrossChainVault public vault;\n\n    // Liquidation parameters\n    uint256 public constant LIQUIDATION_THRESHOLD = 8000; // 80% in basis points\n    uint256 public constant LIQUIDATION_REWARD = 500; // 5% reward for liquidator\n    uint256 public constant MIN_LIQUIDATION_REWARD = 10e18; // 10 USD minimum\n    uint256 public constant MAX_LIQUIDATION_REWARD = 1000e18; // 1000 USD maximum\n    uint256 public constant PRICE_IMPACT_THRESHOLD = 200; // 2% max price impact\n\n    // Automation settings\n    uint256 public lastLiquidationCheck;\n    uint256 public liquidationInterval = 30; // Check every 30 seconds\n    uint256 public maxPositionsPerCheck = 50; // Batch processing limit\n\n    // Fee settings\n    uint256 public liquidationFee = 100; // 1% platform fee\n    address public feeRecipient;\n\n    // Emergency controls\n    bool public emergencyMode = false;\n    uint256 public emergencyLiquidationThreshold = 9000; // 90% in emergency\n\n    // Position tracking\n    mapping(uint256 => bool) public isPositionQueued;\n    // Asset (address or bytes32) => feedId mapping\n    mapping(address => bytes32) public assetToFeedId;\n    uint256[] public liquidationQueue;\n\n    // Liquidator management\n    mapping(address => bool) public authorizedLiquidators;\n    mapping(address => uint256) public liquidatorRewards;\n\n    // Events\n    event PositionLiquidated(\n        uint256 indexed positionId,\n        address indexed trader,\n        address indexed liquidator,\n        uint256 collateralLiquidated,\n        uint256 liquidatorReward,\n        uint256 timestamp\n    );\n\n    event LiquidationQueued(uint256 indexed positionId, uint256 healthRatio);\n    event LiquidationDequeued(uint256 indexed positionId);\n    event EmergencyModeToggled(bool enabled);\n    event LiquidatorAuthorized(address indexed liquidator);\n    event LiquidatorRevoked(address indexed liquidator);\n\n    // Modifiers\n    modifier onlyAuthorizedLiquidator() {\n        require(\n            authorizedLiquidators[msg.sender] || msg.sender == owner(),\n            \"Not authorized liquidator\"\n        );\n        _;\n    }\n\n    modifier validPositionId(uint256 positionId) {\n        require(positionId > 0, \"Invalid position ID\");\n        _;\n    }\n\n    constructor(\n        address _positionManager,\n        address _oracle,\n        address _vault,\n        address _feeRecipient\n    ) Ownable(msg.sender) {\n        positionManager = IPositionManager(_positionManager);\n        oracle = IDataStreamOracle(_oracle);\n        vault = ICrossChainVault(_vault);\n        feeRecipient = _feeRecipient;\n        lastLiquidationCheck = block.timestamp;\n\n        // Owner is automatically authorized liquidator\n        authorizedLiquidators[msg.sender] = true;\n    }\n\n    /**\n     * @dev Chainlink Automation checkUpkeep function\n     * Determines if liquidations need to be performed\n     */\n    function checkUpkeep(\n        bytes calldata\n    )\n        external\n        view\n        override\n        returns (bool upkeepNeeded, bytes memory performData)\n    {\n        // Check if enough time has passed\n        bool timeCondition = (block.timestamp - lastLiquidationCheck) >=\n            liquidationInterval;\n\n        if (!timeCondition || paused()) {\n            return (false, \"\");\n        }\n\n        // Get positions that need liquidation\n        uint256[] memory positionsToLiquidate = _getPositionsToLiquidate();\n\n        if (positionsToLiquidate.length > 0) {\n            // Limit batch size\n            uint256 batchSize = positionsToLiquidate.length >\n                maxPositionsPerCheck\n                ? maxPositionsPerCheck\n                : positionsToLiquidate.length;\n\n            uint256[] memory batch = new uint256[](batchSize);\n            for (uint256 i = 0; i < batchSize; i++) {\n                batch[i] = positionsToLiquidate[i];\n            }\n\n            upkeepNeeded = true;\n            performData = abi.encode(batch);\n        }\n    }\n\n    /**\n     * @dev Chainlink Automation performUpkeep function\n     * Executes liquidations automatically\n     */\n    function performUpkeep(bytes calldata performData) external override {\n        require(!paused(), \"Contract is paused\");\n\n        uint256[] memory positionIds = abi.decode(performData, (uint256[]));\n\n        for (uint256 i = 0; i < positionIds.length; i++) {\n            _executeLiquidation(positionIds[i], address(this));\n        }\n\n        lastLiquidationCheck = block.timestamp;\n    }\n\n    /**\n     * @dev Manual liquidation function for authorized liquidators\n     */\n    function liquidatePosition(\n        uint256 positionId\n    )\n        external\n        nonReentrant\n        whenNotPaused\n        onlyAuthorizedLiquidator\n        validPositionId(positionId)\n    {\n        require(\n            _isPositionLiquidatable(positionId),\n            \"Position not liquidatable\"\n        );\n        _executeLiquidation(positionId, msg.sender);\n    }\n\n    /**\n     * @dev Batch liquidation for multiple positions\n     */\n    function batchLiquidate(\n        uint256[] calldata positionIds\n    ) external nonReentrant whenNotPaused onlyAuthorizedLiquidator {\n        require(positionIds.length <= maxPositionsPerCheck, \"Batch too large\");\n\n        for (uint256 i = 0; i < positionIds.length; i++) {\n            if (_isPositionLiquidatable(positionIds[i])) {\n                _executeLiquidation(positionIds[i], msg.sender);\n            }\n        }\n    }\n\n    /**\n     * @dev Internal liquidation execution\n     */\n    function _executeLiquidation(\n        uint256 positionId,\n        address liquidator\n    ) internal {\n        IPositionManager.Position memory position = positionManager.getPosition(\n            positionId\n        );\n        require(position.isActive, \"Position not active\");\n\n        // Get current price for the asset\n        bytes32 feedId = _getFeedId(positionId); // Implementation depends on your asset mapping\n        (uint256 currentPrice, bool isValid) = oracle.getPriceWithValidation(\n            feedId\n        );\n        require(isValid, \"Invalid price data\");\n\n        // Calculate liquidation amounts\n        uint256 liquidationReward = _calculateLiquidationReward(\n            position.collateral\n        );\n        uint256 platformFee = (position.collateral * liquidationFee) / 10000;\n        uint256 remainingCollateral = position.collateral -\n            liquidationReward -\n            platformFee;\n\n        // Update position PnL before liquidation\n        int256 pnl = _calculatePnL(position, currentPrice);\n        positionManager.updatePositionPnl(positionId, pnl);\n\n        // Execute liquidation through position manager\n        positionManager.closePosition(positionId, currentPrice, liquidator);\n\n        // Handle collateral liquidation\n        vault.liquidateCollateral(\n            position.trader,\n            position.collateral,\n            liquidator\n        );\n\n        // Distribute rewards\n        if (liquidator != address(this)) {\n            liquidatorRewards[liquidator] =\n                liquidatorRewards[liquidator] +\n                liquidationReward;\n        }\n\n        // Remove from queue if present\n        _removeFromQueue(positionId);\n\n        emit PositionLiquidated(\n            positionId,\n            position.trader,\n            liquidator,\n            position.collateral,\n            liquidationReward,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @dev Set the feedId for a given asset (admin only)\n     * @param asset The asset address (or use bytes32 for asset pair)\n     * @param feedId The oracle feedId\n     */\n    function setAssetFeed(address asset, bytes32 feedId) external onlyOwner {\n        require(asset != address(0), \"Invalid asset\");\n        require(feedId != 0, \"Invalid feedId\");\n        assetToFeedId[asset] = feedId;\n    }\n\n    /**\n     * @dev Internal: Get feedId for a position\n     *      Uses the asset address stored in PositionManager\n     */\n    function _getFeedId(uint256 positionId) internal view returns (bytes32) {\n        IPositionManager.Position memory position = positionManager.getPosition(\n            positionId\n        );\n        bytes32 feedId = assetToFeedId[position.asset];\n        require(feedId != 0, \"No feedId set for asset\");\n        return feedId;\n    }\n\n    /**\n     * @dev Check if position is liquidatable\n     */\n    function _isPositionLiquidatable(\n        uint256 positionId\n    ) internal view returns (bool) {\n        IPositionManager.Position memory position = positionManager.getPosition(\n            positionId\n        );\n\n        if (!position.isActive) return false;\n\n        bytes32 feedId = _getFeedId(positionId);\n        (uint256 currentPrice, bool isValid) = oracle.getPriceWithValidation(\n            feedId\n        );\n        if (!isValid) return false;\n\n        int256 pnl = _calculatePnL(position, currentPrice);\n        uint256 healthRatio = _calculateHealthRatio(position, pnl);\n\n        uint256 threshold = emergencyMode\n            ? emergencyLiquidationThreshold\n            : LIQUIDATION_THRESHOLD;\n\n        return healthRatio <= threshold;\n    }\n\n    /**\n     * @dev Calculate position PnL\n     */\n    function _calculatePnL(\n        IPositionManager.Position memory position,\n        uint256 currentPrice\n    ) internal pure returns (int256) {\n        if (position.isLong) {\n            return int256((currentPrice * position.size) / position.entryPrice);\n        } else {\n            return int256((position.entryPrice * position.size) / currentPrice);\n        }\n    }\n\n    /**\n     * @dev Calculate position health ratio (collateral value / position value)\n     */\n    function _calculateHealthRatio(\n        IPositionManager.Position memory position,\n        int256 pnl\n    ) internal pure returns (uint256) {\n        int256 adjustedCollateral = int256(position.collateral) + pnl;\n\n        if (adjustedCollateral <= 0) return 0;\n\n        return (uint256(adjustedCollateral) * 10000) / position.size;\n    }\n\n    /**\n     * @dev Calculate liquidation reward\n     */\n    function _calculateLiquidationReward(\n        uint256 collateral\n    ) internal pure returns (uint256) {\n        uint256 reward = (collateral * LIQUIDATION_REWARD) / 10000;\n\n        if (reward < MIN_LIQUIDATION_REWARD) {\n            reward = MIN_LIQUIDATION_REWARD;\n        } else if (reward > MAX_LIQUIDATION_REWARD) {\n            reward = MAX_LIQUIDATION_REWARD;\n        }\n\n        return reward;\n    }\n\n    /**\n     * @dev Get positions that need liquidation\n     */\n    function _getPositionsToLiquidate()\n        internal\n        view\n        returns (uint256[] memory)\n    {\n        uint256[] memory allPositions = positionManager.getAllActivePositions();\n        uint256[] memory liquidatablePositions = new uint256[](\n            allPositions.length\n        );\n        uint256 count = 0;\n\n        for (uint256 i = 0; i < allPositions.length; i++) {\n            if (_isPositionLiquidatable(allPositions[i])) {\n                liquidatablePositions[count] = allPositions[i];\n                count++;\n            }\n        }\n\n        // Resize array to actual count\n        uint256[] memory result = new uint256[](count);\n        for (uint256 i = 0; i < count; i++) {\n            result[i] = liquidatablePositions[i];\n        }\n\n        return result;\n    }\n\n    /**\n     * @dev Queue position for liquidation\n     */\n    function queuePositionForLiquidation(\n        uint256 positionId\n    ) external onlyAuthorizedLiquidator {\n        require(!isPositionQueued[positionId], \"Position already queued\");\n\n        liquidationQueue.push(positionId);\n        isPositionQueued[positionId] = true;\n\n        IPositionManager.Position memory position = positionManager.getPosition(\n            positionId\n        );\n        bytes32 feedId = _getFeedId(positionId);\n        (uint256 currentPrice, ) = oracle.getLatestPrice(feedId);\n        int256 pnl = _calculatePnL(position, currentPrice);\n        uint256 healthRatio = _calculateHealthRatio(position, pnl);\n\n        emit LiquidationQueued(positionId, healthRatio);\n    }\n\n    /**\n     * @dev Remove position from liquidation queue\n     */\n    function _removeFromQueue(uint256 positionId) internal {\n        if (!isPositionQueued[positionId]) return;\n\n        for (uint256 i = 0; i < liquidationQueue.length; i++) {\n            if (liquidationQueue[i] == positionId) {\n                liquidationQueue[i] = liquidationQueue[\n                    liquidationQueue.length - 1\n                ];\n                liquidationQueue.pop();\n                break;\n            }\n        }\n\n        isPositionQueued[positionId] = false;\n        emit LiquidationDequeued(positionId);\n    }\n\n    // Admin functions\n    function setLiquidationInterval(uint256 _interval) external onlyOwner {\n        liquidationInterval = _interval;\n    }\n\n    function setMaxPositionsPerCheck(uint256 _maxPositions) external onlyOwner {\n        maxPositionsPerCheck = _maxPositions;\n    }\n\n    function setLiquidationFee(uint256 _fee) external onlyOwner {\n        require(_fee <= 1000, \"Fee too high\"); // Max 10%\n        liquidationFee = _fee;\n    }\n\n    function setFeeRecipient(address _feeRecipient) external onlyOwner {\n        require(_feeRecipient != address(0), \"Invalid address\");\n        feeRecipient = _feeRecipient;\n    }\n\n    function toggleEmergencyMode() external onlyOwner {\n        emergencyMode = !emergencyMode;\n        emit EmergencyModeToggled(emergencyMode);\n    }\n\n    function authorizeLiquidator(address liquidator) external onlyOwner {\n        authorizedLiquidators[liquidator] = true;\n        emit LiquidatorAuthorized(liquidator);\n    }\n\n    function revokeLiquidator(address liquidator) external onlyOwner {\n        authorizedLiquidators[liquidator] = false;\n        emit LiquidatorRevoked(liquidator);\n    }\n\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    // View functions\n    function getQueuedPositions() external view returns (uint256[] memory) {\n        return liquidationQueue;\n    }\n\n    function getPositionHealthRatio(\n        uint256 positionId\n    ) external view returns (uint256) {\n        IPositionManager.Position memory position = positionManager.getPosition(\n            positionId\n        );\n        bytes32 feedId = _getFeedId(positionId);\n        (uint256 currentPrice, ) = oracle.getLatestPrice(feedId);\n        int256 pnl = _calculatePnL(position, currentPrice);\n        return _calculateHealthRatio(position, pnl);\n    }\n\n    function isLiquidationDue() external view returns (bool) {\n        return (block.timestamp - lastLiquidationCheck) >= liquidationInterval;\n    }\n\n    // Emergency functions\n    function emergencyWithdraw(\n        address token,\n        uint256 amount\n    ) external view onlyOwner {\n        require(emergencyMode, \"Not in emergency mode\");\n        // Implementation for emergency token withdrawal\n    }\n\n    function updateContracts(\n        address _positionManager,\n        address _oracle,\n        address _vault\n    ) external onlyOwner {\n        if (_positionManager != address(0))\n            positionManager = IPositionManager(_positionManager);\n        if (_oracle != address(0)) oracle = IDataStreamOracle(_oracle);\n        if (_vault != address(0)) vault = ICrossChainVault(_vault);\n    }\n}\n"
  },
  {
    "name": "PerpetuaTrading",
    "path": "PerpetuaTrading.sol",
    "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\n// Importing security and utility contracts from OpenZeppelin and Chainlink\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\"; // Prevents reentrancy attacks\nimport {Pausable} from \"@openzeppelin/contracts/utils/Pausable.sol\"; // Allows contract to be paused/unpaused\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\"; // Provides access control (onlyOwner)\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Interface for ERC20 tokens\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\"; // Safe ERC20 operations\nimport {AutomationCompatibleInterface} from \"@chainlink/contracts/src/v0.8/automation/interfaces/AutomationCompatibleInterface.sol\";\nimport {CrossChainLendingPool} from \"./LendingPool.sol\"; // Importing LendingPool for collateral management;\n\n// IDataStreamOracle interface (unified)\ninterface IDataStreamOracle {\n    function getLatestPrice(\n        bytes32 feedId\n    ) external view returns (uint256 price, uint256 timestamp, uint256 roundId);\n\n    function getPriceWithValidation(\n        bytes32 feedId\n    ) external view returns (uint256 price, bool isValid);\n\n    function getValidatedPrice(\n        bytes32 feedId\n    ) external view returns (uint256 price, uint256 timestamp, bool isValid);\n}\n\n/**\n * @title PerpetualTrading\n * @dev Cross-chain perpetual futures trading contract with Chainlink integration\n * @notice Supports leveraged trading with automated liquidations and cross-chain collateral\n */\ncontract PerpetualTrading is\n    ReentrancyGuard, // Protects functions from reentrancy attacks\n    Pausable, // Allows pausing of contract functions in emergencies\n    Ownable, // Restricts certain functions to the contract owner\n    AutomationCompatibleInterface // Enables Chainlink automation for liquidations\n{\n    using SafeERC20 for IERC20; // Enables safe ERC20 operations\n    CrossChainLendingPool public lendingPool; // Lending pool for collateral management\n    // Constants for precision and limits\n    uint256 public constant PRECISION = 1e18; // Used for decimal calculations\n    uint256 public constant MAX_LEVERAGE = 100; // Maximum leverage allowed (100x)\n    uint256 public constant LIQUIDATION_THRESHOLD = 80; // Liquidation threshold (80% of margin)\n    uint256 public constant LIQUIDATION_PENALTY = 5; // Penalty for liquidation (5%)\n    uint256 public constant TRADING_FEE = 100; // Trading fee (0.1% in basis points)\n    uint256 public constant BASIS_POINTS = 100000; // 100,000 basis points = 100%\n    uint256 public constant STALENESS_THRESHOLD = 300; // 5 minutes\n\n    // Enum for position type: LONG or SHORT\n    enum PositionType {\n        LONG,\n        SHORT\n    }\n    // Enum for position status: OPEN, CLOSED, or LIQUIDATED\n    enum PositionStatus {\n        OPEN,\n        CLOSED,\n        LIQUIDATED\n    }\n\n    // Struct to store information about each trading position\n    struct Position {\n        uint256 id; // Unique position ID\n        address trader; // Address of the trader\n        PositionType positionType; // LONG or SHORT\n        PositionStatus status; // OPEN, CLOSED, or LIQUIDATED\n        uint256 size; // Position size in USD\n        uint256 collateral; // Amount of collateral posted\n        uint256 leverage; // Leverage used\n        uint256 entryPrice; // Price at which position was opened\n        uint256 liquidationPrice; // Price at which position will be liquidated\n        uint256 timestamp; // When the position was opened\n        uint256 lastFundingPayment; // Last time funding was paid\n        bytes32 assetPair; // Asset pair traded (e.g., \"BTC/USD\")\n        address collateralToken; // Token used as collateral\n    }\n\n    // Struct to store market data for each asset pair\n    struct MarketData {\n        bytes32 assetPair; // Asset pair identifier\n        uint256 maxLeverage; // Max leverage for this market\n        uint256 maintenanceMargin; // Maintenance margin in basis points\n        bool isActive; // Whether the market is active\n    }\n\n    // Struct to store funding rate information for each asset pair\n    struct FundingRate {\n        bytes32 assetPair; // Asset pair identifier\n        int256 rate; // Funding rate per hour (can be negative)\n        uint256 lastUpdate; // Last time the funding rate was updated\n    }\n\n    // Mappings to store contract state\n    mapping(uint256 => Position) public positions; // Maps position ID to Position struct\n    mapping(address => uint256[]) public userPositions; // Maps user address to their position IDs\n    mapping(bytes32 => MarketData) public markets; // Maps asset pair to market data\n    mapping(bytes32 => FundingRate) public fundingRates; // Maps asset pair to funding rate\n    mapping(address => mapping(address => uint256)) public userCollateral; // User's collateral per token\n    mapping(uint256 => bool) public positionsToLiquidate; // Tracks positions marked for liquidation\n    mapping(uint256 => uint256) public positionDebt; // positionId => debt amount in collateral token\n\n    uint256 public nextPositionId = 1; // Next position ID to assign\n    uint256 public totalVolume; // Total trading volume\n    uint256 public totalFees; // Total fees collected\n    address public feeRecipient; // Address to receive fees\n    address public liquidationBot; // Address allowed to perform liquidations\n\n    // Supported collateral tokens and their price feeds\n    mapping(address => bool) public supportedTokens;\n    // Asset/collateral to feedId mapping\n    mapping(bytes32 => bytes32) public assetPairToFeedId; // assetPair => feedId\n    mapping(address => bytes32) public tokenToFeedId; // token => feedId\n\n    // Cross-chain related variables\n    address public ccipReceiver; // Address for cross-chain messages\n    mapping(uint256 => bool) public crossChainPositions; // Tracks cross-chain positions\n\n    // Oracle reference\n    IDataStreamOracle public oracle;\n\n    // Events to log important actions\n    event PositionOpened(\n        uint256 indexed positionId,\n        address indexed trader,\n        bytes32 assetPair,\n        PositionType positionType,\n        uint256 size,\n        uint256 collateral,\n        uint256 leverage,\n        uint256 entryPrice\n    );\n\n    event PositionClosed(\n        uint256 indexed positionId,\n        address indexed trader,\n        uint256 exitPrice,\n        int256 pnl,\n        uint256 fees\n    );\n\n    event PositionLiquidated(\n        uint256 indexed positionId,\n        address indexed trader,\n        address indexed liquidator,\n        uint256 liquidationPrice,\n        uint256 penalty\n    );\n\n    event CollateralDeposited(\n        address indexed user,\n        address token,\n        uint256 amount\n    );\n    event CollateralWithdrawn(\n        address indexed user,\n        address token,\n        uint256 amount\n    );\n    event FundingRateUpdated(bytes32 indexed assetPair, int256 rate);\n\n    // Modifier to restrict function to the liquidation bot or owner\n    modifier onlyLiquidationBot() {\n        require(\n            msg.sender == liquidationBot || msg.sender == owner(),\n            \"Only liquidation bot\"\n        );\n        _;\n    }\n\n    // Modifier to restrict function to the CCIP receiver\n    modifier onlyCCIPReceiver() {\n        require(msg.sender == ccipReceiver, \"Only CCIP receiver\");\n        _;\n    }\n\n    // Modifier to check if a market is active\n    modifier validMarket(bytes32 assetPair) {\n        require(markets[assetPair].isActive, \"Market not active\");\n        _;\n    }\n\n    // Constructor sets the fee recipient, initial liquidation bot, and oracle\n    constructor(\n        address _feeRecipient,\n        address _oracle,\n        address _lendingpool\n    ) Ownable(msg.sender) {\n        feeRecipient = _feeRecipient;\n        liquidationBot = msg.sender;\n        lendingPool = CrossChainLendingPool(_lendingpool);\n        oracle = IDataStreamOracle(_oracle);\n    }\n\n    /**\n     * @dev Add a new trading market (only owner)\n     * @param assetPair The asset pair (e.g., \"BTC/USD\")\n     * @param feedId The Chainlink price feed ID\n     * @param maxLeverage Maximum leverage for this market\n     * @param maintenanceMargin Maintenance margin in basis points\n     */\n    function addMarket(\n        bytes32 assetPair,\n        bytes32 feedId,\n        uint256 maxLeverage,\n        uint256 maintenanceMargin\n    ) external onlyOwner {\n        require(maxLeverage <= MAX_LEVERAGE, \"Leverage too high\");\n        require(\n            maintenanceMargin > 0 && maintenanceMargin < 10000,\n            \"Invalid maintenance margin\"\n        );\n        // Store market data\n        markets[assetPair] = MarketData({\n            assetPair: assetPair,\n            maxLeverage: maxLeverage,\n            maintenanceMargin: maintenanceMargin,\n            isActive: true\n        });\n        assetPairToFeedId[assetPair] = feedId;\n        // Initialize funding rate for this market\n        fundingRates[assetPair] = FundingRate({\n            assetPair: assetPair,\n            rate: 0,\n            lastUpdate: block.timestamp\n        });\n    }\n\n    /**\n     * @dev Add a supported collateral token (only owner)\n     * @param token The ERC20 token address\n     * @param feedId The Chainlink price feed ID\n     */\n    function addSupportedToken(\n        address token,\n        bytes32 feedId\n    ) external onlyOwner {\n        supportedTokens[token] = true;\n        tokenToFeedId[token] = feedId;\n    }\n\n    /**\n     * @dev Deposit collateral to the contract\n     * @param token The ERC20 token address\n     * @param amount The amount to deposit\n     */\n    function depositCollateral(\n        address token,\n        uint256 amount\n    ) external nonReentrant {\n        require(supportedTokens[token], \"Token not supported\");\n        require(amount > 0, \"Amount must be positive\");\n\n        // Transfer tokens from user to contract\n        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n        // Update user's collateral balance\n        userCollateral[msg.sender][token] += amount;\n\n        emit CollateralDeposited(msg.sender, token, amount);\n    }\n\n    /**\n     * @dev Withdraw collateral from the contract\n     * @param token The ERC20 token address\n     * @param amount The amount to withdraw\n     */\n    function withdrawCollateral(\n        address token,\n        uint256 amount\n    ) external nonReentrant {\n        require(supportedTokens[token], \"Token not supported\");\n        require(\n            userCollateral[msg.sender][token] >= amount,\n            \"Insufficient collateral\"\n        );\n\n        // Ensure withdrawal won't undercollateralize user's open positions\n        require(\n            _canWithdrawCollateral(msg.sender, token, amount),\n            \"Would undercollateralize positions\"\n        );\n\n        // Update user's collateral balance\n        userCollateral[msg.sender][token] -= amount;\n        // Transfer tokens back to user\n        IERC20(token).safeTransfer(msg.sender, amount);\n\n        emit CollateralWithdrawn(msg.sender, token, amount);\n    }\n\n    /**\n     * @dev Open a new perpetual trading position\n     * @param assetPair The asset pair to trade\n     * @param positionType LONG or SHORT\n     * @param size Position size in USD\n     * @param leverage Leverage to use\n     * @param collateralToken Token used as collateral\n     */\n    function openPosition(\n        bytes32 assetPair,\n        PositionType positionType,\n        uint256 size,\n        uint256 leverage,\n        address collateralToken\n    ) external nonReentrant whenNotPaused validMarket(assetPair) {\n        require(size > 0, \"Size must be positive\");\n        require(\n            leverage > 0 && leverage <= markets[assetPair].maxLeverage,\n            \"Invalid leverage\"\n        );\n        require(\n            supportedTokens[collateralToken],\n            \"Collateral token not supported\"\n        );\n\n        // Calculate required collateral for the position\n        uint256 requiredCollateral = size / leverage;\n        uint256 collateralValue = _getCollateralValue(\n            msg.sender,\n            collateralToken\n        );\n        require(\n            collateralValue >= requiredCollateral,\n            \"Insufficient collateral\"\n        );\n\n        // Get current price\n        uint256 currentPrice = _getAssetPrice(assetPair);\n        uint256 liquidationPrice = _calculateLiquidationPrice(\n            positionType,\n            currentPrice,\n            leverage,\n            markets[assetPair].maintenanceMargin\n        );\n\n        // Calculate trading fee\n        uint256 fee = (size * TRADING_FEE) / BASIS_POINTS;\n        uint256 feeInCollateral = _convertUSDToToken(fee, collateralToken);\n        require(\n            userCollateral[msg.sender][collateralToken] >=\n                feeInCollateral + requiredCollateral,\n            \"Insufficient collateral for fee and margin\"\n        );\n\n        // Calculate and borrow leveraged amount\n        uint256 borrowAmount = size - requiredCollateral;\n        lendingPool.borrow(collateralToken, borrowAmount);\n\n        // Update collateral balances\n        userCollateral[msg.sender][collateralToken] -= feeInCollateral;\n        userCollateral[msg.sender][collateralToken] -= requiredCollateral;\n        totalFees += fee;\n\n        Position memory newPosition = Position({\n            id: nextPositionId,\n            trader: msg.sender,\n            positionType: positionType,\n            status: PositionStatus.OPEN,\n            size: size,\n            collateral: requiredCollateral,\n            leverage: leverage,\n            entryPrice: currentPrice,\n            liquidationPrice: liquidationPrice,\n            timestamp: block.timestamp,\n            lastFundingPayment: block.timestamp,\n            assetPair: assetPair,\n            collateralToken: collateralToken\n        });\n\n        positions[nextPositionId] = newPosition;\n        userPositions[msg.sender].push(nextPositionId);\n\n        // Record debt for position\n        positionDebt[nextPositionId] = borrowAmount;\n\n        emit PositionOpened(\n            nextPositionId,\n            msg.sender,\n            assetPair,\n            positionType,\n            size,\n            requiredCollateral,\n            leverage,\n            currentPrice\n        );\n\n        totalVolume += size; // Update total trading volume\n        nextPositionId++; // Increment position ID for next position\n    }\n\n    /**\n     * @dev Close an open position (only position owner)\n     * @param positionId The ID of the position to close\n     */\n    function closePosition(uint256 positionId) external nonReentrant {\n        Position storage position = positions[positionId];\n        require(position.trader == msg.sender, \"Not position owner\");\n        require(position.status == PositionStatus.OPEN, \"Position not open\");\n\n        uint256 currentPrice = _getAssetPrice(position.assetPair);\n        int256 fundingPayment = _calculateFundingPayment(positionId);\n        int256 pnl = _calculatePnL(position, currentPrice);\n        pnl -= fundingPayment;\n\n        uint256 exitFee = (position.size * TRADING_FEE) / BASIS_POINTS;\n\n        // Repay debt to lending pool\n        uint256 debt = positionDebt[positionId];\n        if (debt > 0) {\n            lendingPool.repay(position.collateralToken, debt);\n            delete positionDebt[positionId];\n        }\n\n        // Settle position\n        _settlePosition(position, pnl, exitFee);\n        position.status = PositionStatus.CLOSED;\n\n        emit PositionClosed(positionId, msg.sender, currentPrice, pnl, exitFee);\n    }\n\n    /**\n     * @dev Liquidate an undercollateralized position (only liquidation bot)\n     * @param positionId The ID of the position to liquidate\n     */\n    function liquidatePosition(\n        uint256 positionId\n    ) external onlyLiquidationBot nonReentrant {\n        Position storage position = positions[positionId];\n        require(position.status == PositionStatus.OPEN, \"Position not open\");\n\n        // Get current price of the asset\n        uint256 currentPrice = _getAssetPrice(position.assetPair);\n        // Check if position is eligible for liquidation\n        require(\n            _isLiquidatable(position, currentPrice),\n            \"Position not liquidatable\"\n        );\n\n        // Calculate penalty for liquidation\n        uint256 penalty = (position.collateral * LIQUIDATION_PENALTY) / 100;\n        if (positionDebt[positionId] > 0) {\n            uint256 repayAmount = positionDebt[positionId];\n            uint256 contractBalance = IERC20(position.collateralToken)\n                .balanceOf(address(this));\n            if (repayAmount > contractBalance) {\n                repayAmount = contractBalance;\n            }\n            if (repayAmount > 0) {\n                lendingPool.repay(position.collateralToken, repayAmount);\n                delete positionDebt[positionId];\n            }\n        }\n        // Mark position as liquidated\n        position.status = PositionStatus.LIQUIDATED;\n\n        // Remaining collateral (if any) is returned to trader\n        uint256 remainingCollateral = position.collateral > penalty\n            ? position.collateral - penalty\n            : 0;\n\n        emit PositionLiquidated(\n            positionId,\n            position.trader,\n            msg.sender,\n            currentPrice,\n            penalty\n        );\n    }\n\n    /**\n     * @dev Update funding rate for an asset pair (only owner)\n     * @param assetPair The asset pair\n     * @param newRate The new funding rate\n     */\n    function updateFundingRate(\n        bytes32 assetPair,\n        int256 newRate\n    ) external onlyOwner {\n        fundingRates[assetPair].rate = newRate;\n        fundingRates[assetPair].lastUpdate = block.timestamp;\n\n        emit FundingRateUpdated(assetPair, newRate);\n    }\n\n    /**\n     * @dev Chainlink Automation: Check if upkeep (liquidation) is needed\n     * @return upkeepNeeded True if any positions need liquidation\n     * @return performData Encoded list of positions to liquidate\n     */\n    function checkUpkeep(\n        bytes calldata\n    )\n        external\n        view\n        override\n        returns (bool upkeepNeeded, bytes memory performData)\n    {\n        uint256[] memory liquidatablePositions = new uint256[](100); // Max 100 per batch\n        uint256 count = 0;\n\n        // Loop through all positions to find liquidatable ones\n        for (uint256 i = 1; i < nextPositionId && count < 100; i++) {\n            Position storage position = positions[i];\n            if (position.status == PositionStatus.OPEN) {\n                uint256 currentPrice = _getAssetPrice(position.assetPair);\n                if (_isLiquidatable(position, currentPrice)) {\n                    liquidatablePositions[count] = i;\n                    count++;\n                }\n            }\n        }\n\n        if (count > 0) {\n            // Resize array to actual count\n            uint256[] memory result = new uint256[](count);\n            for (uint256 i = 0; i < count; i++) {\n                result[i] = liquidatablePositions[i];\n            }\n            upkeepNeeded = true;\n            performData = abi.encode(result);\n        }\n    }\n\n    /**\n     * @dev Chainlink Automation: Perform upkeep (liquidate positions)\n     * @param performData Encoded list of positions to liquidate\n     */\n    function performUpkeep(bytes calldata performData) external override {\n        uint256[] memory positionIds = abi.decode(performData, (uint256[]));\n\n        for (uint256 i = 0; i < positionIds.length; i++) {\n            Position storage position = positions[positionIds[i]];\n            if (position.status == PositionStatus.OPEN) {\n                uint256 currentPrice = _getAssetPrice(position.assetPair);\n                if (_isLiquidatable(position, currentPrice)) {\n                    // Perform liquidation\n                    uint256 penalty = (position.collateral *\n                        LIQUIDATION_PENALTY) / 100;\n                    position.status = PositionStatus.LIQUIDATED;\n\n                    emit PositionLiquidated(\n                        positionIds[i],\n                        position.trader,\n                        address(this),\n                        currentPrice,\n                        penalty\n                    );\n                }\n            }\n        }\n    }\n\n    // =========================\n    // Internal Helper Functions\n    // =========================\n\n    /**\n     * @dev Get the latest price for an asset pair from Chainlink\n     * @param assetPair The asset pair\n     * @return price The latest price (scaled to PRECISION)\n     */\n    function _getAssetPrice(bytes32 assetPair) internal view returns (uint256) {\n        bytes32 feedId = assetPairToFeedId[assetPair];\n        require(feedId != 0, \"No feed for asset pair\");\n        (uint256 price, uint256 timestamp, bool isValid) = oracle\n            .getValidatedPrice(feedId);\n        require(isValid, \"Oracle price invalid or circuit breaker active\");\n        require(price > 0, \"Invalid price\");\n        require(\n            block.timestamp - timestamp < STALENESS_THRESHOLD,\n            \"Stale price\"\n        );\n        return price;\n    }\n\n    /**\n     * @dev Get the value of a user's collateral in USD\n     * @param user The user's address\n     * @param token The collateral token\n     * @return value The value in USD\n     */\n    function _getCollateralValue(\n        address user,\n        address token\n    ) internal view returns (uint256) {\n        uint256 balance = userCollateral[user][token];\n        if (balance == 0) return 0;\n        bytes32 feedId = tokenToFeedId[token];\n        require(feedId != 0, \"No feed for token\");\n        (uint256 price, uint256 timestamp, bool isValid) = oracle\n            .getValidatedPrice(feedId);\n        require(isValid, \"Oracle price invalid or circuit breaker active\");\n        require(price > 0, \"Invalid token price\");\n        require(\n            block.timestamp - timestamp < STALENESS_THRESHOLD,\n            \"Stale price\"\n        );\n        return (balance * price) / PRECISION;\n    }\n\n    /**\n     * @dev Convert a USD amount to the equivalent amount in a token\n     * @param usdAmount The amount in USD\n     * @param token The token address\n     * @return tokenAmount The equivalent token amount\n     */\n    function _convertUSDToToken(\n        uint256 usdAmount,\n        address token\n    ) internal view returns (uint256) {\n        bytes32 feedId = tokenToFeedId[token];\n        require(feedId != 0, \"No feed for token\");\n        (uint256 price, uint256 timestamp, bool isValid) = oracle\n            .getValidatedPrice(feedId);\n        require(isValid, \"Oracle price invalid or circuit breaker active\");\n        require(price > 0, \"Invalid token price\");\n        require(\n            block.timestamp - timestamp < STALENESS_THRESHOLD,\n            \"Stale price\"\n        );\n        return (usdAmount * PRECISION) / price;\n    }\n\n    /**\n     * @dev Calculate the liquidation price for a position\n     * @param positionType LONG or SHORT\n     * @param entryPrice The price at which position was opened\n     * @param leverage The leverage used\n     * @param maintenanceMargin Maintenance margin in basis points\n     * @return liquidationPrice The price at which position will be liquidated\n     */\n    function _calculateLiquidationPrice(\n        PositionType positionType,\n        uint256 entryPrice,\n        uint256 leverage,\n        uint256 maintenanceMargin\n    ) internal pure returns (uint256) {\n        uint256 liquidationMargin = (maintenanceMargin * PRECISION) /\n            BASIS_POINTS;\n\n        if (positionType == PositionType.LONG) {\n            // For long: liquidation when price drops\n            uint256 priceChange = (entryPrice *\n                (PRECISION - liquidationMargin)) / (leverage * PRECISION);\n            return entryPrice - priceChange;\n        } else {\n            // For short: liquidation when price rises\n            uint256 priceChange = (entryPrice *\n                (PRECISION - liquidationMargin)) / (leverage * PRECISION);\n            return entryPrice + priceChange;\n        }\n    }\n\n    /**\n     * @dev Calculate profit or loss (PnL) for a position\n     * @param position The position struct\n     * @param currentPrice The current price of the asset\n     * @return pnl The profit or loss (can be negative)\n     */\n    function _calculatePnL(\n        Position memory position,\n        uint256 currentPrice\n    ) internal pure returns (int256) {\n        int256 priceDiff;\n\n        if (position.positionType == PositionType.LONG) {\n            priceDiff = int256(currentPrice) - int256(position.entryPrice);\n        } else {\n            priceDiff = int256(position.entryPrice) - int256(currentPrice);\n        }\n\n        return\n            (priceDiff * int256(position.size)) / int256(position.entryPrice);\n    }\n\n    /**\n     * @dev Calculate funding payment for a position\n     * @param positionId The position ID\n     * @return payment The funding payment (can be negative)\n     */\n    function _calculateFundingPayment(\n        uint256 positionId\n    ) internal view returns (int256) {\n        Position storage position = positions[positionId];\n        FundingRate storage fundingRate = fundingRates[position.assetPair];\n\n        uint256 timeElapsed = block.timestamp - position.lastFundingPayment;\n        uint256 hoursElapsed = timeElapsed / 3600; // Convert to hours\n\n        int256 payment = (int256(position.size) *\n            fundingRate.rate *\n            int256(hoursElapsed)) / (int256(BASIS_POINTS) * 24);\n\n        // Long positions pay positive funding rates, short positions receive them\n        if (position.positionType == PositionType.SHORT) {\n            payment = -payment;\n        }\n\n        return payment;\n    }\n\n    /**\n     * @dev Check if a position is eligible for liquidation\n     * @param position The position struct\n     * @param currentPrice The current price of the asset\n     * @return isLiquidatable True if position should be liquidated\n     */\n    function _isLiquidatable(\n        Position memory position,\n        uint256 currentPrice\n    ) internal pure returns (bool) {\n        if (position.positionType == PositionType.LONG) {\n            return currentPrice <= position.liquidationPrice;\n        } else {\n            return currentPrice >= position.liquidationPrice;\n        }\n    }\n\n    /**\n     * @dev Check if user can withdraw collateral without undercollateralizing positions\n     * @param user The user's address\n     * @param token The collateral token\n     * @param amount The amount to withdraw\n     * @return canWithdraw True if withdrawal is allowed\n     */\n    function _canWithdrawCollateral(\n        address user,\n        address token,\n        uint256 amount\n    ) internal view returns (bool) {\n        // Get user's open positions\n        uint256[] memory userPos = userPositions[user];\n        // Calculate remaining collateral after withdrawal\n        uint256 remainingCollateral = userCollateral[user][token] - amount;\n        uint256 remainingValue = _getTokenValue(remainingCollateral, token);\n\n        uint256 totalRequired = 0;\n        // Sum required collateral for all open positions\n        for (uint256 i = 0; i < userPos.length; i++) {\n            Position memory pos = positions[userPos[i]];\n            if (pos.status == PositionStatus.OPEN) {\n                totalRequired += pos.collateral;\n            }\n        }\n\n        return remainingValue >= totalRequired;\n    }\n\n    /**\n     * @dev Get the value of a token amount in USD\n     * @param amount The token amount\n     * @param token The token address\n     * @return value The value in USD\n     */\n    function _getTokenValue(\n        uint256 amount,\n        address token\n    ) internal view returns (uint256) {\n        if (amount == 0) return 0;\n        bytes32 feedId = tokenToFeedId[token];\n        require(feedId != 0, \"No feed for token\");\n        (uint256 price, uint256 timestamp, bool isValid) = oracle\n            .getValidatedPrice(feedId);\n        require(isValid, \"Oracle price invalid or circuit breaker active\");\n        require(price > 0, \"Invalid token price\");\n        require(\n            block.timestamp - timestamp < STALENESS_THRESHOLD,\n            \"Stale price\"\n        );\n        return (amount * price) / PRECISION;\n    }\n\n    /**\n     * @dev Settle a closed position (update balances, etc.)\n     * @param position The position struct\n     * @param pnl The profit or loss\n     * @param fee The exit fee\n     */\n    function _settlePosition(\n        Position memory position,\n        int256 pnl,\n        uint256 fee\n    ) internal {\n        // Implementation depends on collateral token used for the position\n        // This is a simplified version - full implementation would track collateral token per position\n        totalFees += fee;\n    }\n\n    // =========================\n    // View Functions\n    // =========================\n\n    /**\n     * @dev Get details of a position by ID\n     * @param positionId The position ID\n     * @return position The Position struct\n     */\n    function getPosition(\n        uint256 positionId\n    ) external view returns (Position memory) {\n        return positions[positionId];\n    }\n\n    /**\n     * @dev Get all position IDs for a user\n     * @param user The user's address\n     * @return positionIds Array of position IDs\n     */\n    function getUserPositions(\n        address user\n    ) external view returns (uint256[] memory) {\n        return userPositions[user];\n    }\n\n    /**\n     * @dev Get market data for an asset pair\n     * @param assetPair The asset pair\n     * @return marketData The MarketData struct\n     */\n    function getMarketData(\n        bytes32 assetPair\n    ) external view returns (MarketData memory) {\n        return markets[assetPair];\n    }\n\n    /**\n     * @dev Get user's collateral balance for a token\n     * @param user The user's address\n     * @param token The token address\n     * @return amount The collateral amount\n     */\n    function getUserCollateral(\n        address user,\n        address token\n    ) external view returns (uint256) {\n        return userCollateral[user][token];\n    }\n\n    // =========================\n    // Admin Functions (onlyOwner)\n    // =========================\n\n    /**\n     * @dev Set the CCIP receiver address (only owner)\n     * @param _ccipReceiver The new CCIP receiver address\n     */\n    function setCCIPReceiver(address _ccipReceiver) external onlyOwner {\n        ccipReceiver = _ccipReceiver;\n    }\n\n    /**\n     * @dev Set the liquidation bot address (only owner)\n     * @param _liquidationBot The new liquidation bot address\n     */\n    function setLiquidationBot(address _liquidationBot) external onlyOwner {\n        liquidationBot = _liquidationBot;\n    }\n\n    /**\n     * @dev Set the fee recipient address (only owner)\n     * @param _feeRecipient The new fee recipient address\n     */\n    function setFeeRecipient(address _feeRecipient) external onlyOwner {\n        feeRecipient = _feeRecipient;\n    }\n\n    /**\n     * @dev Set the oracle address (only owner)\n     * @param _oracle The new oracle address\n     */\n    function setOracle(address _oracle) external onlyOwner {\n        require(_oracle != address(0), \"Invalid oracle address\");\n        oracle = IDataStreamOracle(_oracle);\n    }\n\n    /**\n     * @dev Pause the contract (only owner)\n     */\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    /**\n     * @dev Unpause the contract (only owner)\n     */\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    /**\n     * @dev Emergency withdraw all tokens from contract (only owner)\n     * @param token The token address\n     */\n    function emergencyWithdraw(address token) external onlyOwner {\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        IERC20(token).safeTransfer(owner(), balance);\n    }\n\n    /**\n     * @dev Set the lending pool address (only owner)\n     * @param _lendingPool The new lending pool address\n     */\n    function setLendingPool(address _lendingPool) external onlyOwner {\n        require(_lendingPool != address(0), \"Invalid lending pool address\");\n        lendingPool = CrossChainLendingPool(_lendingPool);\n    }\n\n    // Modify the getpositions function to return status as uint\n    function getpositions(\n        uint id\n    )\n        external\n        view\n        returns (\n            uint256,\n            address,\n            PositionType,\n            uint status, // Change enum to uint\n            uint256,\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        )\n    {\n        Position storage p = positions[id];\n        return (\n            p.id,\n            p.trader,\n            p.positionType,\n            uint(p.status), // Explicit conversion\n            p.size,\n            p.collateral,\n            p.leverage,\n            p.entryPrice,\n            p.liquidationPrice\n        );\n    }\n}\n"
  },
  {
    "name": "PositionManager",
    "path": "PositionManager.sol",
    "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\nimport {ReentrancyGuard} from \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n// Add interface for DataStreamOracle\ninterface IDataStreamOracle {\n    function getLatestPrice(\n        bytes32 feedId\n    ) external view returns (uint256 price, uint256 timestamp, uint256 roundId);\n}\n\n/**\n * @title PositionManager\n * @dev Manages perpetual trading positions, margin calculations, and position tracking\n */\ncontract PositionManager is ReentrancyGuard, Ownable {\n    // ============ STRUCTS ============\n\n    struct Position {\n        uint256 positionId;\n        address trader;\n        address asset;\n        uint256 size;\n        uint256 entryPrice;\n        uint256 margin;\n        uint256 leverage;\n        bool isLong;\n        uint256 timestamp;\n        bool isOpen;\n        uint256 unrealizedPnl;\n        int256 realizedPnl;\n    }\n\n    struct PositionStats {\n        uint256 totalPositions;\n        uint256 openPositions;\n        uint256 totalVolume;\n        int256 totalPnl;\n    }\n\n    // ============ STATE VARIABLES ============\n\n    mapping(uint256 => Position) public positions;\n    mapping(address => uint256[]) public userPositions;\n    mapping(address => PositionStats) public userStats;\n\n    uint256 public nextPositionId;\n    uint256 public totalPositions;\n    uint256 public totalVolume;\n\n    // Configuration\n    uint256 public minMargin = 100 * 10 ** 18; // 100 USDC minimum\n    uint256 public maxLeverage = 100; // 100x max leverage\n    uint256 public liquidationThreshold = 80 * 10 ** 16; // 80% threshold\n\n    // Oracle reference\n    IDataStreamOracle public oracle;\n    // Staleness threshold per asset (can be set per asset if needed)\n    mapping(address => uint256) public stalenessThreshold;\n    // Add to PositionManager\n    mapping(address => bytes32) public assetToFeedId;\n\n    address public liquidationEngine;\n\n    // ============ CONSTRUCTOR ============\n\n    constructor(address _oracle) Ownable(msg.sender) {\n        oracle = IDataStreamOracle(_oracle);\n    }\n\n    // ============ EVENTS ============\n\n    event PositionOpened(\n        uint256 indexed positionId,\n        address indexed trader,\n        address indexed asset,\n        uint256 size,\n        uint256 entryPrice,\n        uint256 margin,\n        uint256 leverage,\n        bool isLong\n    );\n\n    event PositionClosed(\n        uint256 indexed positionId,\n        address indexed trader,\n        uint256 exitPrice,\n        uint256 pnl,\n        bool isProfit\n    );\n\n    event PositionLiquidated(\n        uint256 indexed positionId,\n        address indexed trader,\n        uint256 liquidationPrice,\n        uint256 loss\n    );\n\n    event MarginAdded(\n        uint256 indexed positionId,\n        address indexed trader,\n        uint256 amount\n    );\n\n    event MarginRemoved(\n        uint256 indexed positionId,\n        address indexed trader,\n        uint256 amount\n    );\n\n    // ============ MODIFIERS ============\n\n    modifier onlyPositionOwner(uint256 positionId) {\n        require(\n            positions[positionId].trader == msg.sender,\n            \"Not position owner\"\n        );\n        _;\n    }\n\n    modifier onlyOpenPosition(uint256 positionId) {\n        require(positions[positionId].isOpen, \"Position not open\");\n        _;\n    }\n\n    modifier onlyLiquidationEngine() {\n        require(\n            msg.sender == liquidationEngine,\n            \"Not authorized liquidation engine\"\n        );\n        _;\n    }\n\n    // ============ CORE FUNCTIONS ============\n\n    function setAssetFeed(address asset, bytes32 feedId) external onlyOwner {\n        assetToFeedId[asset] = feedId;\n    }\n\n    function getPositionAsset(\n        uint256 positionId\n    ) external view returns (address) {\n        return positions[positionId].asset;\n    }\n\n    /**\n     * @dev Open a new perpetual position\n     * @param asset Asset being traded\n     * @param size Position size\n     * @param entryPrice Entry price\n     * @param margin Margin amount\n     * @param leverage Leverage multiplier\n     * @param isLong True for long position, false for short\n     */\n    function openPosition(\n        address asset,\n        uint256 size,\n        uint256 entryPrice,\n        uint256 margin,\n        uint256 leverage,\n        bool isLong\n    ) external nonReentrant returns (uint256 positionId) {\n        require(size > 0, \"Size must be greater than 0\");\n        require(entryPrice > 0, \"Entry price must be greater than 0\");\n        require(margin >= minMargin, \"Margin below minimum\");\n        require(leverage <= maxLeverage, \"Leverage exceeds maximum\");\n        require(leverage > 0, \"Leverage must be greater than 0\");\n\n        // Get latest price and staleness check\n        bytes32 feedId = keccak256(abi.encodePacked(asset));\n        (uint256 oraclePrice, uint256 timestamp, ) = oracle.getLatestPrice(\n            feedId\n        );\n        require(oraclePrice > 0, \"Invalid oracle price\");\n        uint256 threshold = stalenessThreshold[asset] > 0\n            ? stalenessThreshold[asset]\n            : 300; // default 5 min\n        require(block.timestamp - timestamp <= threshold, \"Stale price\");\n        entryPrice = oraclePrice;\n\n        // Calculate required margin\n        uint256 requiredMargin = (size * entryPrice) / leverage;\n        require(margin >= requiredMargin, \"Insufficient margin\");\n\n        positionId = nextPositionId++;\n\n        Position storage position = positions[positionId];\n        position.positionId = positionId;\n        position.trader = msg.sender;\n        position.asset = asset;\n        position.size = size;\n        position.entryPrice = entryPrice;\n        position.margin = margin;\n        position.leverage = leverage;\n        position.isLong = isLong;\n        position.timestamp = block.timestamp;\n        position.isOpen = true;\n        position.unrealizedPnl = 0;\n        position.realizedPnl = 0;\n\n        // Update user positions\n        userPositions[msg.sender].push(positionId);\n\n        // Update statistics\n        userStats[msg.sender].totalPositions++;\n        userStats[msg.sender].openPositions++;\n        userStats[msg.sender].totalVolume += size;\n\n        totalPositions++;\n        totalVolume += size;\n\n        emit PositionOpened(\n            positionId,\n            msg.sender,\n            asset,\n            size,\n            entryPrice,\n            margin,\n            leverage,\n            isLong\n        );\n\n        return positionId;\n    }\n\n    /**\n     * @dev Close an open position\n     * @param positionId Position ID to close\n     * @param exitPrice Exit price\n     */\n    function closePosition(\n        uint256 positionId,\n        uint256 exitPrice\n    )\n        external\n        nonReentrant\n        onlyPositionOwner(positionId)\n        onlyOpenPosition(positionId)\n    {\n        Position storage position = positions[positionId];\n        require(exitPrice > 0, \"Exit price must be greater than 0\");\n\n        // Calculate P&L\n        uint256 pnl;\n        bool isProfit;\n\n        if (position.isLong) {\n            if (exitPrice > position.entryPrice) {\n                pnl =\n                    ((exitPrice - position.entryPrice) * position.size) /\n                    position.entryPrice;\n                isProfit = true;\n            } else {\n                pnl =\n                    ((position.entryPrice - exitPrice) * position.size) /\n                    position.entryPrice;\n                isProfit = false;\n            }\n        } else {\n            if (exitPrice < position.entryPrice) {\n                pnl =\n                    ((position.entryPrice - exitPrice) * position.size) /\n                    position.entryPrice;\n                isProfit = true;\n            } else {\n                pnl =\n                    ((exitPrice - position.entryPrice) * position.size) /\n                    position.entryPrice;\n                isProfit = false;\n            }\n        }\n\n        // Update position\n        position.isOpen = false;\n        position.realizedPnl = isProfit ? int256(pnl) : -int256(pnl);\n\n        // Update user statistics\n        userStats[msg.sender].openPositions--;\n        if (isProfit) {\n            userStats[msg.sender].totalPnl += int256(pnl);\n        } else {\n            userStats[msg.sender].totalPnl -= int256(pnl);\n        }\n\n        emit PositionClosed(positionId, msg.sender, exitPrice, pnl, isProfit);\n    }\n\n    /**\n     * @dev Add margin to an open position\n     * @param positionId Position ID\n     * @param amount Amount to add\n     */\n    function addMargin(\n        uint256 positionId,\n        uint256 amount\n    )\n        external\n        nonReentrant\n        onlyPositionOwner(positionId)\n        onlyOpenPosition(positionId)\n    {\n        require(amount > 0, \"Amount must be greater than 0\");\n\n        Position storage position = positions[positionId];\n        position.margin += amount;\n\n        emit MarginAdded(positionId, msg.sender, amount);\n    }\n\n    /**\n     * @dev Remove margin from an open position\n     * @param positionId Position ID\n     * @param amount Amount to remove\n     */\n    function removeMargin(\n        uint256 positionId,\n        uint256 amount\n    )\n        external\n        nonReentrant\n        onlyPositionOwner(positionId)\n        onlyOpenPosition(positionId)\n    {\n        require(amount > 0, \"Amount must be greater than 0\");\n\n        Position storage position = positions[positionId];\n        require(position.margin > amount, \"Insufficient margin to remove\");\n\n        // Check if removal would trigger liquidation\n        uint256 remainingMargin = position.margin - amount;\n        uint256 requiredMargin = (position.size * position.entryPrice) /\n            position.leverage;\n        require(\n            remainingMargin >= requiredMargin,\n            \"Removal would trigger liquidation\"\n        );\n\n        position.margin -= amount;\n\n        emit MarginRemoved(positionId, msg.sender, amount);\n    }\n\n    /**\n     * @dev Update unrealized P&L for a position\n     * @param positionId Position ID\n     * @param currentPrice Current market price\n     */\n    function updateUnrealizedPnl(\n        uint256 positionId,\n        uint256 currentPrice\n    ) external onlyOpenPosition(positionId) {\n        Position storage position = positions[positionId];\n\n        uint256 pnl;\n\n        if (position.isLong) {\n            if (currentPrice > position.entryPrice) {\n                pnl =\n                    ((currentPrice - position.entryPrice) * position.size) /\n                    position.entryPrice;\n            } else {\n                pnl =\n                    ((position.entryPrice - currentPrice) * position.size) /\n                    position.entryPrice;\n            }\n        } else {\n            if (currentPrice < position.entryPrice) {\n                pnl =\n                    ((position.entryPrice - currentPrice) * position.size) /\n                    position.entryPrice;\n            } else {\n                pnl =\n                    ((currentPrice - position.entryPrice) * position.size) /\n                    position.entryPrice;\n            }\n        }\n\n        position.unrealizedPnl = pnl;\n    }\n\n    /**\n     * @dev Liquidate a position (called by liquidation engine)\n     * @param positionId Position ID to liquidate\n     * @param liquidationPrice Liquidation price\n     */\n    function liquidatePosition(\n        uint256 positionId,\n        uint256 liquidationPrice\n    ) external onlyOpenPosition(positionId) onlyLiquidationEngine {\n        Position storage position = positions[positionId];\n\n        // Calculate loss\n        uint256 loss = position.margin; // Simplified - actual calculation would be more complex\n\n        // Update position\n        position.isOpen = false;\n        position.realizedPnl = -int256(loss);\n\n        // Update user statistics\n        userStats[position.trader].openPositions--;\n        userStats[position.trader].totalPnl -= int256(loss);\n\n        emit PositionLiquidated(\n            positionId,\n            position.trader,\n            liquidationPrice,\n            loss\n        );\n    }\n\n    // ============ VIEW FUNCTIONS ============\n\n    /**\n     * @dev Get position details\n     * @param positionId Position ID\n     * @return position Position struct\n     */\n    function getPosition(\n        uint256 positionId\n    ) external view returns (Position memory position) {\n        return positions[positionId];\n    }\n\n    /**\n     * @dev Get user's positions\n     * @param user User address\n     * @return positionIds Array of position IDs\n     */\n    function getUserPositions(\n        address user\n    ) external view returns (uint256[] memory positionIds) {\n        return userPositions[user];\n    }\n\n    /**\n     * @dev Get user's statistics\n     * @param user User address\n     * @return stats User statistics\n     */\n    function getUserStats(\n        address user\n    ) external view returns (PositionStats memory stats) {\n        return userStats[user];\n    }\n\n    /**\n     * @dev Calculate position health factor\n     * @param positionId Position ID\n     * @param currentPrice Current market price\n     * @return healthFactor Health factor (0-100)\n     */\n    function calculateHealthFactor(\n        uint256 positionId,\n        uint256 currentPrice\n    ) external view returns (uint256 healthFactor) {\n        Position storage position = positions[positionId];\n        if (!position.isOpen) return 0;\n\n        // Calculate current value\n        uint256 currentValue = (position.size * currentPrice) /\n            position.entryPrice;\n        uint256 requiredMargin = (position.size * position.entryPrice) /\n            position.leverage;\n\n        if (currentValue <= requiredMargin) {\n            return 0;\n        }\n\n        return ((currentValue - requiredMargin) * 100) / requiredMargin;\n    }\n\n    // ============ ADMIN FUNCTIONS ============\n\n    /**\n     * @dev Update minimum margin requirement\n     * @param _minMargin New minimum margin\n     */\n    function updateMinMargin(uint256 _minMargin) external onlyOwner {\n        minMargin = _minMargin;\n    }\n\n    /**\n     * @dev Update maximum leverage\n     * @param _maxLeverage New maximum leverage\n     */\n    function updateMaxLeverage(uint256 _maxLeverage) external onlyOwner {\n        maxLeverage = _maxLeverage;\n    }\n\n    /**\n     * @dev Update liquidation threshold\n     * @param _liquidationThreshold New liquidation threshold\n     */\n    function updateLiquidationThreshold(\n        uint256 _liquidationThreshold\n    ) external onlyOwner {\n        liquidationThreshold = _liquidationThreshold;\n    }\n\n    function setLiquidationEngine(address _engine) external onlyOwner {\n        require(_engine != address(0), \"Invalid address\");\n        liquidationEngine = _engine;\n    }\n}\n"
  }
]